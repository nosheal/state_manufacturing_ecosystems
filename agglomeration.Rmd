---
title: "Varieties of Agglomeration"
author: "Nikhil Kalathil"
date: "2023-12-04"
output: html_document
---

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warnings = FALSE)
```

```{r, include = FALSE}
#Libraries
library(tigris)
library(tidyverse)
library(here)
library(leaflet)
library(ggrepel)
library(RColorBrewer)
library(grid)
library(gridExtra)
library(cowplot)
library(readxl)
library(janitor)
library(geofacet)
library(jsonlite)
library(ggridges)
library(sf)
library(here)
library(patchwork)
library(plotly)
library(leaflet.extras)

set.seed(37)
title_theme <- theme(axis.text = element_text(size = 14), 
        axis.title = element_text(size = 18), 
        title = element_text(size = 20))

axis_theme <- theme(axis.text = element_text(size = 10), 
        axis.title = element_text(size = 18))
```

```{r, include = FALSE}
#Area Crosswalks
area_codes <- readRDS(here("State Data/area_crosswalk.RDS")) %>% 
  mutate(area_title = str_remove(area_title, " -- Statewide")) %>% 
  mutate(area_fips = case_when(
    nchar(area_fips) == 4 ~ paste("0", area_fips, sep = ""), 
    TRUE ~ area_fips
  ))

states <- data.frame(state_abbr = state.abb, area_title = state.name)

area_codes <- left_join(area_codes, states) %>% 
  mutate(state_abbr = case_when(
    area_title == "District of Columbia" ~ "DC",
    area_title == "Puerto Rico" ~ "PR",
    TRUE ~ state_abbr))
```


```{r}
ExpandColorsLIGHT <- function(colors, n, steps = 11){
  if(n <= steps){
    suppressWarnings({
      sapply(colors, function(x){colorRampPalette(c(x, "#FFFFFF"))(steps)}) %>% 
        as.data.frame() %>% 
        filter(row_number() <= n) %>% 
        gather(key = original.color, value = expanded.color)
    })
  }else{
    warning("Select n < steps!")
  }
}
```


```{r}
ExpandColorsDARK <- function(colors, n, steps = 11){
  if(n <= steps){
    suppressWarnings({
      sapply(colors, function(x){colorRampPalette(c(x, "#000000"))(steps)}) %>% 
        as.data.frame() %>% 
        filter(row_number() <= n) %>% 
        gather(key = original.color, value = expanded.color)
    })
  }else{
    warning("Select n < steps!")
  }
}
```

```{r, include = FALSE}
#Map Data
county_sf <- counties(cb = TRUE) %>% 
  shift_geometry(position = "outside")
states_sf <- states(cb = TRUE, resolution = "20m") %>%
  shift_geometry(position = "outside")
```

```{r, include = FALSE}
#Change projection of data for leaflet

states_leaflet <- states_sf %>% 
  sf::st_transform('+proj=longlat +datum=WGS84')

counties_leaflet <- county_sf %>% 
  sf::st_transform('+proj=longlat +datum=WGS84') 
```

```{r, include = FALSE}
#Convert county data to a table
county_data <- counties_leaflet %>% 
  as_tibble() %>% 
  select(STATEFP, COUNTYFP) %>% 
  mutate(area_fips = paste(STATEFP, COUNTYFP, sep = ""), 
         st = as.numeric(STATEFP))
```


```{r, include = FALSE}
#Get center of each county
county_centers <- counties_leaflet %>% 
  filter(str_detect(NAME, "Mariana", negate = TRUE)) %>% 
  st_centroid() %>% 
  sf::st_transform('+proj=longlat +datum=WGS84')
```

```{r, include = FALSE}
#Load Existing Data
qcew_3digits <- readRDS(here("State Data/qcew_3digit.RDS")) %>% 
  mutate(industry_desc = substring(industry_title, 11))
```

```{r, include = FALSE}
#Simplify to get industry codes
ind_3digit <- qcew_3digits %>% 
  select(naics_3digit = ind_code, naics_3digit_label = industry_desc) %>% 
  distinct() %>% 
  arrange(naics_3digit_label)
```

```{r, include = FALSE}
#Define colors 
emp_ind_vector <- c(brewer.pal(9, "Greys")[4], "#cf4633", "#BEAED4", "#FDC086", "#FDBF6F",  "#386CB0", "#FB8072", brewer.pal(9, "Greys")[3], brewer.pal(9, "Greys")[8], "#80B1D3", "#F0027F",  "#4DAF4A", "#F1E2CC", "#6A3D9A", "#E78AC3", "#CBD5E8", "#666666", brewer.pal(9, "Greys")[5],  brewer.pal(9, "Greys")[6], "#A65628", brewer.pal(9, "Greys")[7])
```

```{r}
#create data frame mapping colors to industries
col_map <- data.frame(ind_3digit$naics_3digit_label, emp_ind_vector)
```

```{r}
rd_col <- data.frame(ind_3digit.naics_3digit_label = "Scientific R&D", emp_ind_vector = "#8DD3C7")
```

```{r}
col_map <- bind_rows(col_map, rd_col)
```


```{r}
# Map 3-digit NAICS to 3-digit Colors
get_col_vec <- function(data){ 
  data %>% 
    select(naics_3digit_label) %>% 
    distinct() %>% 
    unlist()
  }
```

```{r}
#Function to get appropriate 3-digit colors
get_col_match <- function(data){ 
  
 col_vec <- get_col_vec(data)
 
 col_out <- col_map %>% 
   filter(ind_3digit.naics_3digit_label %in% col_vec) %>% 
   select(emp_ind_vector) %>% 
   unlist() %>% 
   unname()
 
  return(col_out)
  
}
```

```{r}
#Get County GEOIDS and crosswalks
cbp_geoid <- read.csv(here("County Data/5_digit_naics_2019.csv")) %>% 
  mutate(area_fips = str_sub(GEO_ID, -5)) %>% 
  select(GEO_ID, NAME, area_fips) %>% distinct()

cbp_empzes <- read.csv(here("County Data/5_digit_naics_2019.csv")) %>% 
  select(EMPSZES_LABEL, EMPSZES) %>% 
  distinct()

cbp_io <- readRDS(here("Input Output Data/cbp_manf_IO_crosswalk.RDS"))
```


```{r, include = FALSE}
#read county-level manufacturing data
cbp_2019 <- read.csv(here("County Data/6_digit_naics_CBP.csv")) %>% 
  left_join(cbp_geoid) %>% 
  left_join(county_data) %>% 
  left_join(area_codes %>% select(st, state_abbr)) %>% 
  mutate(across(.cols = c(EMP, ESTAB), ~ gsub(",", "", .)),
    emp_num = as.numeric(EMP), 
    ESTAB = as.numeric(ESTAB)) %>% 
  filter(str_detect(NAME, "Mariana", negate = TRUE))
```

```{r}
#read Input Output Data
use_table_final <- readRDS(here("Input Output Data/use_table_final.RDS"))
sup_com_agg <- readRDS(here("Input Output Data/sup_com_agg.RDS"))
ind_agg <- readRDS(here("Input Output Data/ind_agg.RDS"))
com_agg <- readRDS(here("Input Output Data/com_agg.RDS"))
supply_table_final <- readRDS(here("Input Output Data/supply_table_final.RDS"))
```


```{r}
#Read NAICS Codes
naics_codes <- read.csv(here("NAICS/naics_codes.csv")) %>% 
  select(c(2,3))

colnames(naics_codes) <- c("industry_code", "industry_desc")
```

```{r, include = FALSE}
naics_2 <- naics_codes %>% 
  filter(str_length(industry_code) == 2 | industry_code == "31-33") %>% 
  mutate(industry_code = case_when(
    industry_code == "31-33" ~ 31.33, 
    TRUE ~ as.numeric(industry_code)
  ))
```

```{r}
naics_sub <- function(var, num){
   as.numeric(str_sub({{ var }}, 1, num))
}
```

# Overview

This document performs a geospatial mapping of manufacturing activity based on shared use and supply of various commodities. This analysis updates and incorporates existing industrial clustering algorithms to provide a new perspective on the geographic and sectoral organization of manufacturing activity in 2019 across the United States.

# Connecting Use and Supply 

## Theoretical Background

The connection of use and supply tables is a complicated task. Extensive work has been done using Input-Output tables to identify national clusters of US industries (Delgado and Mills, 2020; Delgado et al., 2014; Feser and Bergman, 2010), deriving between 22 and 28 unique clusters (on the order of magnitude of 3-digit NAICS manufacturing codes), but little work has been done to identify how the use and supply of commodities by industries might vary geographically. Because previous work has been focused on understanding how industries are connected in general, they chose not to focus on regional variation in the use and supply of commodities. I leverage the fact that industries are sparsely and endogenously distributed across the United States to highlight new geographic and sectoral patterns in the structure and composition of contemporary manufacturing activity. 

The 2017 Input-Output Accounts Data cover the domestic supply and use of commodities by 405 industries. These data provide the dollar value of the output and use of commodities. The lack of quantity information certainly complicates this analysis, as certain commodities are per-unit more valuable. However, these data still provide a baseline for estimating linkages between industries sectors. 

For a given industry $i$, let $C_i$ be the vector of commodities that industry i purchases as intermediate inputs (minus imports). Let $P_i$ be the vector of commodities that industry $i$ outputs (minus exports). Adding imports and exports is saved as a robustness check. I adapt and extend the approach used by Fraser and Bergman, 2000. 

Let $X_{C_i}$ be a matrix with columns representing industries and rows representing the value of the commodities that these industries purchase. Focusing on the manufacturing sector, the input-output use table results in a 232x326 matrix of 232 manufacturing industries (i), and their use of 326 commodities (c).  The first measure I define is $x_{i,c}$: the value of commodity c as an intermediate input in industry i over the total value of intermediate inputs used by industry $i$: $\frac{i_p}{i_{int}}$

Performing correlation analysis, I define $r(x_i, x_j)$, which measures the degree to which industries $i$ and $j$ have similar input purchasing patterns. 

Let $Y_{P_i}$ then be a matrix with columns representing industries and the rows representing the value of the commodities that these industries output. Focusing on the the manufacturing sector, the input-output supply table data results in a 232x255 matrix of 232 manufacturing industries (i), and their output of 255 commodities (c). NAICS codes inherently capture $r(y_i, y_j)$: the measure of the degree to which industries $i$ and $j$ and similar output patterns. However, I formalize this by defining $y_{p, i}$ as the value of production of commodity p as a share of the total value of output by industry $i$:  $\frac{p_i}{p_{tot}}$. This measure can alternatively be calculated as the value of production of commodity p by industry i as a share of total production of commodity p. Let this alternative calculation be denoted by $y_{i, p}$

Neither of these measures, however, captures how industries are inherently linked together. Unfortunately, data in the 2017 supply table do not differentiate production for use an intermediate input from production as a final output. For example, the value of use of Scientific R&D as an input is just over \$12,000, but the value of output of scientific R&D as a commodity is over \$650,000. Fortunately, not every product is used as an intermediary product. Let $\lambda_c = c_{int} / c_{tot}$ be the share of the value of the total output of commodity c that is used as an intermediate input. 

I construct a matrix $M_{i,j}$, with each column denoting the vector of industries $j$ that supply $i$. An in this matrix, for given industries $i$ and $j$ is constructed as follows. 

For all commodities that industry $j$ outputs, let $m_{i,j}$ be the sum over the products that industry $j$ outputs ($p_{i,j}$) that belong to the set of commodities $C_i$, of: the commodities that industry $i$ uses as intermediate inputs, the share of the value of the total output of commodity p that is used as an intermediate input ($\lambda_p$), and the value of commodity p as an intermediate input in industry i over the total value of intermediate inputs used by industry $i$. 

$$m_{i,j} = \sum_{P_c \in C_i} Y_{j,p}*\lambda_p * x_{i,p} = \sum_{P_c \in C_i} \frac{p_j}{p_{tot}}*\frac{p_{int}}{p_{tot}} * \frac{i_p}{i_{int}}$$

Thus, the vector $m_i$ captures the intensity of supply to industry $i$ that each other industry $j$ consists of. This measure could technically be abstracted one level further, to consider the degree to which an industry $j$ supplies to other industries $l$ that industry $i$ uses as its main suppliers. This calculation is also saved as a robustness check. 

With this specification, a given industry $j$ is considered a supplier of industry $i$ if $m_{ij}$ is above some threshold.

## Implementation

The above calculations can be constructed with the following datasets: the final use table, the final supply table, the industry aggregate table, and the commodity aggregate table. The construction of these datasets are provided in the input_output.rmd cleaning file. 

I make some initial cleaning adjustments to some of these tables to begin. 

```{r}
#Take the aggregate industry output measures and summarize them. 
manf_ind <- ind_agg %>% 
  mutate(naics_3digit = as.numeric(str_sub(industry_code, 1, 3))) %>% 
  left_join(ind_3digit) %>% 
  filter(naics_3digit >= 300 & naics_3digit < 400) %>% 
  #FIX MISSING VALUES WITH 0
  mutate(across(.cols = c(3:7), ~ case_when(
    is.na(.) ~ 0, 
    TRUE ~ .)), 
    log_ind = log(industry_output), 
    log_value = log(value_added), 
    log_inputs = log(intermediary_inputs), 
    val_ratio = value_added/industry_output, 
    input_ratio = intermediary_inputs/industry_output, 
    log_imports = log(imports), 
    import_ratio = imports/intermediary_inputs) 
```


### Inputs 

```{r}
#focus on manufacturing sector, join with manufacturing aggregate and create share
manf_inputs <- use_table_final %>% 
  filter(naics_3digit >= 300 & naics_3digit < 400) %>% 
  select(-c(value, value_clean)) %>% 
  left_join(manf_ind) %>% 
  mutate(input_share = value_num / intermediary_inputs) %>% 
  ungroup() %>% 
  arrange(industry_code)
```

```{r}
ind_crosswalk <- manf_inputs %>% 
  ungroup() %>% 
  select(industry_code, industry_desc, naics_3digit, naics_3digit_label) %>% 
  distinct()
```

```{r}
saveRDS(ind_crosswalk, here("Input Output Data/ind_crosswalk.RDS"))
```



```{r}
com_list <- manf_inputs %>% 
  select(commodity_code) %>% 
  distinct() %>% 
  unlist() %>% 
  unname()
```

```{r}
ind_list <- manf_inputs %>% 
  select(industry_code) %>% 
  distinct() %>% 
  unlist() %>% 
  unname()
```

Here, the individual row entries of the matrix $X_{C_i}$ are given by the value of each $x_{i,c}$. I create a 232x326 matrix of 232 manufacturing industries (i), and their use of 326 commodities (c).  

```{r}
#create wide dataframe with each row being an industry and each column being a commodity 
input_cluster_share <- manf_inputs %>% 
  select(commodity_code, commodity_desc, industry_desc, industry_code, value_num, input_share) %>% 
  pivot_wider(id_cols = c(industry_desc, industry_code), values_from = input_share, names_from = commodity_code, values_fill = 0)
```


```{r}
input_matrix <- input_cluster_share %>% 
  select(-c(industry_code, industry_desc)) %>% 
  as.matrix()
```

### Lambda_C

At this point, I construct $\lambda_c$. 

```{r}
lambda_c <- com_agg %>% 
  filter(commodity_code %in% com_list) %>% 
  mutate(com_share = intermediate / total_use) %>% 
  select(com_share, commodity_code)
```

So far, calculations have all been done with the use database. Introducing the supply of commodities requires a different database. 

### Outputs

```{r}
manf_supply <- supply_table_final %>% 
  filter(naics_3digit >= 300 & naics_3digit < 400) %>% 
  left_join(sup_com_agg) %>% 
  mutate(manf_percent = value_num / total_commodity_output) %>% #percentage of a given output that is manufactured by a given manufacturing industry
  left_join(ind_agg) %>% 
  mutate(supply_percent = value_num / industry_output) %>%  #percentage of total industry supply that a given output makes up
  group_by(industry_code) %>% 
  mutate(prod_num = n(), #Number of total products an industry produces 
         main_prod = max(supply_percent, na.rm = TRUE),
         manf_sup = manf_percent*supply_percent) %>% #Across all commodities an industry produces, the maximum of the percentage of total industry supply a given output makes up
  arrange(industry_code)
```


```{r}
#list of goods made by the manufacturing industry
com_code_list <- manf_supply %>% 
  ungroup() %>% 
  select(commodity_code) %>% 
  distinct() %>% 
  unlist() %>% 
  unname()
```

I now create a 232 x 254 matrix, with the rows being individual industries, and columns being the commodities that industry outputs. The column number is indexed by a list of all commodity codes. 

```{r}
output_clustering <- manf_supply %>% 
  ungroup() %>% 
  select(commodity_code, commodity_desc, industry_desc, industry_code, value_num, manf_percent, supply_percent, manf_sup) %>% 
  pivot_wider(id_cols = c(industry_desc, industry_code), values_from = manf_percent, names_from = commodity_code, values_fill = 0) 
```

```{r}
output_matrix_raw <- output_clustering %>% 
  ungroup() %>% 
  select(-c(industry_desc, industry_code)) %>% 
  as.matrix()
```

### Final Analysis

I now turn to the task of creating the final 232x232 measurement. 

```{r}
mat_holder <- matrix(0, 232, 232)
```


#### Semiconductor Case Study

Consider the case of the semiconductor and related devices manufacturing industry, industry 334413. This industry uses 109 different inputs, the majority of which come from semiconductor and related industries, and the next highest of which come from nonferrous metal manufacturing. 

```{r}
#Get List of Inputs for Industry in Question
 input_list <- manf_inputs %>% 
    filter(industry_code %in% c("334413"), value_num > 0) %>% 
    select(commodity_code) %>% 
    unlist() %>% 
    unname()
  
```

Of these 109 inputs, 73 are in the manufacturing sector make table. 

```{r}
  #Match the commodity codes to the index of commodity codes we have (supply)
  com_list_sup <- which(com_code_list %in% input_list) %>% 
    unlist() %>% 
    unname()

#get the list of supplied commodities
supplied_commodities <- com_code_list[com_list_sup]
```


Certain commodities, such as custom computer programming are used far less intensively as an intermediate output than others are across all products (e.g. Asphalt paving and concrete mix). $\lambda_c$ accounts for the share of value that intermediate inputs account for, relative to the total value of that commodity.

```{r}
#Get the lambda_c vector
lambda_inputs <- lambda_c %>% 
    filter(commodity_code %in% supplied_commodities) %>% 
    select(com_share) %>% 
    unlist() %>% 
    unname() 
```

From the matrix of outputs $Y_{P_i}$, extract the columns that correspond to the inputs used by industry $i$. The resulting matrix details the total production of inputs used by industry $i$ across all $j$. To focus on a specific $j$, select a specific row. 

```{r}
output_matrix <- output_matrix_raw[, com_list_sup] %>% as.matrix()
```

Now, the challenge is to turn to the input data. The above matrix $X_{C_i}$ details the share of value of total intermediate inputs used by industry $i$ that come from a specific commodity $c$. Because the indexing of commodities is slightly different in the input clustering data than the output clustering data, a new indexing system is needed. 

```{r}
input_com_list <- which(com_list %in% supplied_commodities) 
```

This list can then be applied to the input share matrix $X_{C_i}$ to identify a subset of the matrix about how every other industry uses the set of inputs that industry $i$ uses. Again, the specific row value denoted by industry $i$ contains information about the total use of commodity output by industry $i$. 

```{r}
ind_row <- which(ind_list %in% c("334413"))
```


```{r}
input_results <- input_matrix[, input_com_list] %>% as.matrix()
```

The output of this matrix can be validated to be correct, where the value of the $x_{i,c}$ entry represents the value of the use of a specific commodity $c$ by an industry $i$ as a share of the total value of the use of all intermediate inputs by industry $i$. As noted above, this matrix also contains useful information about how other industries that are not $i$ use the same set of inputs that industry $i$ uses. Most entries outside of the row given by $i$ and its immediately related neighbors are zero. Summing over each row, I calculate the share of total industry supply provided by the set of "supplied commodities." As a note, because a sometimes substantial amount of non-manufactured inputs are used as intermediate inputs by manufacturing sub-sectors, the total amount of intermediate input supply provided by supplied commodities for a given industry in question can sometimes be very low (e.g just over 50% in the case of semiconductor manufacturing.). This limitation makes a strong case for the inclusion of all commodity output in this analysis, and not just commodities produced by the manufacturing sector. However, I press forward to attempt to complete a proof of concept for this work. 

```{r}
input_sums <- input_results %>% rowSums()
```

For semiconductor manufacturing, there appears to be a natural cutoff at around 40% of total industry supply, as illustrated in the graph below. This figure also illustrates how certain 3-digit sectors are overall closer to the use of inputs as the semiconductor industry than others. For the purpose of this analysis, I use 40% as a cutoff for every sector, however, a proper robustness test might involve returning to this, and dynamically selecting this number. For example, 40% here falls just below the 50th percentile of observations in this data. 

```{r}
related_ind <- data.frame(input_results) %>% 
  mutate(ind_i = ind_list,
    row_sums = input_sums) %>% 
  select(row_sums, ind_i, everything())
```

```{r}
rel_ind_clean <- related_ind %>% 
  select(row_sums, industry_code = ind_i) %>% 
  left_join(ind_crosswalk) %>% 
  group_by(naics_3digit_label) %>% mutate(count = n()) %>% filter(count > 3) %>% 
  ungroup()

rel_ind_col <- get_col_match(rel_ind_clean)

related_industries_graph <- rel_ind_clean %>% 
  ggplot(aes(x = row_sums, y = naics_3digit_label, fill = factor(naics_3digit_label))) + 
  geom_density_ridges(aes(), alpha = 0.7, jittered_points = TRUE, point_alpha=1,point_shape=21) + 
  scale_fill_manual(values = rel_ind_col) + 
  guides(fill = "none") + 
  labs(x = "Total Share of Industry Intermediate Input in Supplied Commodities", y = 
         "NAICS 3-digit Summary") + 
  theme_bw() + 
  axis_theme

related_industries_graph
```


```{r}
#Transform to matrix
rel_ind <- related_ind %>% 
  filter(row_sums > .4) %>% 
  mutate(ind_order = seq(n())) %>% 
  select(ind_i, ind_order) 

rel_ind_matrix <- related_ind %>% 
  filter(row_sums > .4) %>% 
  select(-c(row_sums, ind_i)) %>% 
  as.matrix()
```

The resulting matrix is a subset of the initial 232 manufacturing subsectors for which the value of the set of inputs produced by the manufacturing sector used by industry $i$ accounts for over 40% of that sub-sector's value of the total use of intermediate inputs. As above, I calculate the correlation between a specific industry $i$'s input vector, and other industries input vectors as well. Here, the goal is to identify the subset of other industries that are most similar to industry $i$ in their use of similar commodities produced by the manufacturing sector: $r(x_{i,c}, x_{j,c})$ 

```{r}
ind_cor <- as.dist(1-cor(t(rel_ind_matrix), method = c("pearson"))) %>% as.matrix()
```

The $i$'th row of this correlation matrix provides the correlation across all other manufacturing industries above a specific threshold, with industry $i$. 

```{r}
ind_index <- rel_ind[rel_ind$ind_i == "334413", 2]

ind_cor_df <- data.frame(industry_code = rel_ind$ind_i, industry_cor = ind_cor[ind_index,]) %>%
  left_join(ind_crosswalk)
```

At some point, examining these matrices more thoroughly may provide useful information. However, for the moment, gathering the top three contenders should be sufficient. 

```{r}
ind_cor_out <- ind_cor_df %>% 
  arrange(desc(industry_cor)) %>% 
  mutate(tal = seq(n())) %>% 
  filter(tal < 4) %>% 
  select(industry_code, industry_desc, naics_3digit_label, industry_cor) %>% 
  mutate(industry_i = "334413") 
```

I conclude by finally combining the supply and use tables together. Taking the matrix of the use of inputs, I multiply this by the transpose of the matrix of the production of outputs, normalized by the commodity input use vector. 

```{r}
# Here we do element wise multiplication across the rows 
com_adj <- output_matrix*lambda_inputs
```


```{r}
#Final Matrix 
result_matrix <- input_results %*% t(output_matrix) 
```

The resulting matrix is very complicated, but very interesting. For the row that corresponds to industry i, the matrix details the intensity of supply from all other manufacturing sectors.

However, every other row of the matrix details how each other industry j uses the same inputs as industry i, and how other industries supply this use of inputs. This might prove very informative in the future, but at the moment is discarded. 

```{r}
# Check that results make general sense. 

output <- as.data.frame(result_matrix) 
colnames(output) <- ind_list
output %>% 
  mutate(ind_i = ind_list) %>% 
  pivot_longer(cols = -c(ind_i), names_to = "ind_j", values_to = "m_ij") %>% 
  left_join(ind_crosswalk %>% 
              rename(ind_i = industry_code, ind_i_desc = industry_desc)) %>% 
  left_join(ind_crosswalk %>% 
              select(ind_j = industry_code, ind_j_desc = industry_desc))
```

The resulting vector is an $i$ by $j$ vector, representing the intensity through which every other $j$ manufacturing sub-sector (including $i$), supplies intermediate inputs to $i$. This vector is saved to the initial matrix holder in the appropriately row. Thus, each row represents a vector of the industries that supply $i$, and each column represents the vector of industries that are supplied by $i$, populated by a measure of the intensity of supply. 

```{r}
output_result <- result_matrix[ind_index,] 
```

#### Expanding the Process

This process must be performed over all industries $i$. Fortunately, the above process covers all possible $j$ for a given industry $i$. I define a function to capture the above process, iterate through every $i$ in the dataset. The output is a final matrix $M_{i,j}$, where each row represents a vector of the industries that supply $i$, and each column represents the vector of industries that are supplied by $i$, populated by a measure of the intensity of supply. In addition, I output a long-formatted dataframe indexing the top 3-most correlated industries in terms of use of similar inputs, for each industry $i$. 

```{r}
input_correlated_ind <- ind_cor_out[0,]
```

```{r}
mat_holder <- matrix(0, 232, 232)
```



```{r}
get_input_results <- function(industry){ 
  
  #Get List of Inputs for a specific industry I 
  input_list <- manf_inputs %>% 
    filter(industry_code %in% c(industry), value_num > 0) %>% 
    select(commodity_code) %>% 
    unlist() %>% 
    unname()
  
  
  #Match the commodity codes to the index of commodity codes we have (supply)
  com_list_sup <- which(com_code_list %in% input_list) %>% 
    unlist() %>% 
    unname()
  
  #Get the list of supplied commodities
  supplied_commodities <- com_code_list[com_list_sup]
  
  #Get the lambda_c vector
  lambda_inputs <- lambda_c %>% 
      filter(commodity_code %in% supplied_commodities) %>% 
      select(com_share) %>% 
      unlist() %>% 
      unname() 
  
  #From the matrix of outputs $Y_{P_i}$, extract the columns that correspond to the inputs used by industry $i$. 
  output_matrix <- output_matrix_raw[, com_list_sup] %>% as.matrix()
  
  # Perform element wise multiplication across the rows to normalize by use of commodity as an input
  com_adj <- output_matrix*lambda_inputs
  
  #Get Index for Supplied Commodities in Input Data
  input_com_list <- which(com_list %in% supplied_commodities) 
  
  #Get Index for Industry I 
  ind_row <- which(ind_list %in% c(industry))
  
  #From the matrix of inputs $X_{C_i}$, extract the input columns that correspond to the inputs used by a given industry I. 
  input_results <- input_matrix[, input_com_list] %>% as.matrix()
  
  return(input_results)
  }
```

```{r}
get_industry_outputs <- function(industry){
  
  #Get List of Inputs for a specific industry I 
  input_list <- manf_inputs %>% 
    filter(industry_code %in% c(industry), value_num > 0) %>% 
    select(commodity_code) %>% 
    unlist() %>% 
    unname()
  
  
  #Match the commodity codes to the index of commodity codes we have (supply)
  com_list_sup <- which(com_code_list %in% input_list) %>% 
    unlist() %>% 
    unname()
  
  #Get the list of supplied commodities
  supplied_commodities <- com_code_list[com_list_sup]
  
  #Get the lambda_c vector
  lambda_inputs <- lambda_c %>% 
      filter(commodity_code %in% supplied_commodities) %>% 
      select(com_share) %>% 
      unlist() %>% 
      unname() 
  
  #From the matrix of outputs $Y_{P_i}$, extract the columns that correspond to the inputs used by industry $i$. 
  output_matrix <- output_matrix_raw[, com_list_sup] %>% as.matrix()
  
  # Perform element wise multiplication across the rows to normalize by use of commodity as an input
  com_adj <- output_matrix*lambda_inputs
  
  #Get Index for Supplied Commodities in Input Data
  input_com_list <- which(com_list %in% supplied_commodities) 
  
  #Get Index for Industry I 
  ind_row <- which(ind_list %in% c(industry))
  
  #From the matrix of inputs $X_{C_i}$, extract the input columns that correspond to the inputs used by a given industry I. 
  input_results <- input_matrix[, input_com_list] %>% as.matrix()
  
  #Results matrix
  result_matrix <- input_results %*% t(output_matrix) 

  #Final output
  result_matrix[ind_index,] 
}
```



```{r}
get_correlated_industries <- function(industry, inputs){
  
  input_results <- inputs
  #Get Row Sums for each industry (total value of intermediate inputs by manufacturing industries that supply i)
  input_sums <- input_results %>% rowSums()
  
   #get related industries dataframe
  related_ind <- data.frame(input_results) %>% 
  mutate(ind_i = ind_list,
    row_sums = input_sums) %>% 
  select(row_sums, ind_i, everything())
  
  #Transform to matrix
  rel_ind <- related_ind %>% 
    filter(row_sums > .4) %>% 
    mutate(ind_order = seq(n())) %>% 
    select(ind_i, ind_order) 
  
  rel_ind_matrix <- related_ind %>% 
    filter(row_sums > .4) %>% 
    select(-c(row_sums, ind_i)) %>% 
    as.matrix()
  
  #Get Correlation across industries
  ind_cor <- as.dist(1-cor(t(rel_ind_matrix), method = c("pearson"))) %>% 
    as.matrix()
  
  ind_cor_out <- ind_cor_df %>% 
    arrange(desc(industry_cor)) %>% 
    mutate(tal = seq(n())) %>% 
    filter(tal < 4) %>% 
    select(industry_code, industry_desc, naics_3digit_label, industry_cor) %>% 
    mutate(industry_i = industry) 
  
  return(ind_cor_out)
}
```



```{r}
for (i in 1:length(ind_list)){
  
  indstry <- as.character(ind_list[i])
  
  mat_holder[i, ] <- get_industry_outputs(indstry)
  
  input_correlated_ind <- bind_rows(input_correlated_ind,
                                    get_correlated_industries(indstry,                                                        get_input_results(indstry)))
  
}
```


```{r}
results_df <- as.data.frame(mat_holder)

colnames(results_df) <- ind_list

results_long <- results_df %>% 
  mutate(industry_i = ind_list) %>% 
  select(industry_i, everything()) %>% 
  pivot_longer( col = -c(industry_i), names_to = "industry_j", values_to = "m_ij")
```

```{r}
saveRDS(results_long, here("Input Output Data/results_matrix.RDS"))
saveRDS(input_correlated_ind, here("Input Output Data/ind_corr.RDS"))
```


At the conclusion of this analysis, the input-output tables yield 3 separate measures of how industries are related: 

1. $r(x_{i,c}, x_{j,c})$: measures the degree to which industries $i$ and $j$ use the same input mix. This measure captures vertical agglomeration. 

2. $r(y_{i,p}, y_{j,p})$: measures the degree to which industries $i$ and $j$ produce the same output mix, highly correlated with NAICS. This measure captures horizontal agglomeration

3. $r(m_{i,j}, m_{j,i})$ measures the degree to which industries $i$ and $j$ source inputs from similar sets of suppliers. This measures is an improved measure of vertical agglomeration from (1). 


# From Industries to Geographies

Using the above constructed Input Output Data, I now map the use and supply of commodities by the manufacturing sector to county-level establishments details. The geographic distribution of manufacturing activity is heterogeneous and sparse. Defining the use or supply of a given vector of commodities by industries located in a county requires some measure of the absolute and relative intensity of county-level industrial activity. Following in Delgado et. al, 2014, I use employment and establishments as the main measure of county-level industrial activity. This analysis could easily be extended to use GDP or sales as a measure. 

## Theoretical Background 

The sparse geographic location of 6-digit level manufacturing establishments allows for a careful investigation of the use and supply of commodities by the manufacturing sector. Let $m$ be the total number of manufacturing sub-sectors, and $n$ be the total number of counties across the nation. For each county $g$ and manufacturing sub-sector $i$, let $\phi_{g, i}$ be the share of national sub-sector activity in that county. This measure captures the total concentration of sub-sector activity that occurs in a specific county:

$$\phi_{i,g} = \frac{i_g}{\sum_{i=1}^m i}$$
This measure needs to be modified to account for skews in concentration of certain industries in certain geographies. Fortunately, the location quotient for an industry provides for a standard and useful correction here. The location quotient is defined as the county's share of a specific industry, divided by the average county share for that industry across the nation:

$$LQ_{g,i} = \frac{\phi_{i,g}}{( \frac{1}{n} \sum_{g=1}^{n} \phi_{i,g})}$$


Thus, a measure of industrial activity in a given county can be approximated by: 

$$\tilde{A}_{g,i} = \phi_{i,g} * LQ_{g,i}$$ 

The above Input-Output section maps industry activity to the production and use of specific vectors of commodities. As such, I do not need to specifically map individual industries to commodities. Instead, I estimate the relatedness between a specific manufacturing sub-sector $i_g$ and the manufacturing sub-sectors located within a specific distance from that sub-sector as a function of that county's industrial activity in a given sub-sector, $\tilde{A}_{g,i}$, and the derived input-output measure of the relatedness between geographically differentiated manufacturing sub-sectors $i_g$ and $j_g$, for all $j_g$ within a specific radius of the county of interest (let the set of these counties and industries be given by $\theta$). 

$$\tilde{A}_{g,i}*r(i_g, j_g \forall g \in \theta)$$

This specification allows for testing the robustness of this analysis to different geographic thresholds of distance (such as defined by commute patterns), as well as different thresholds for industrial measures of relatedness. However, it also allows for the plotting of raw values of industrial relatedness based on geographic distances. 

## Implementation

I turn to the implementation of the above measures across 2019 County Business Pattern Data, with 2017 Input Output Accounts Data. 