---
title: "Varieties of Agglomeration"
author: "Nikhil Kalathil"
date: "2023-12-04"
output: html_document
---

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warnings = FALSE)
```

```{r, include = FALSE}
#Libraries
library(tigris)
library(tidyverse)
library(here)
library(leaflet)
library(ggrepel)
library(RColorBrewer)
library(grid)
library(gridExtra)
library(cowplot)
library(readxl)
library(janitor)
library(geofacet)
library(jsonlite)
library(ggridges)
library(sf)
library(here)
library(patchwork)
library(plotly)
library(leaflet.extras)
library(units)

set.seed(37)
title_theme <- theme(axis.text = element_text(size = 14), 
        axis.title = element_text(size = 18), 
        title = element_text(size = 20))

axis_theme <- theme(axis.text = element_text(size = 10), 
        axis.title = element_text(size = 18), 
         strip.text.x = element_text(size = 14))
```

```{r, include = FALSE}
#Area Crosswalks
area_codes <- readRDS(here("State Data/area_crosswalk.RDS")) %>% 
  mutate(area_title = str_remove(area_title, " -- Statewide")) %>% 
  mutate(area_fips = case_when(
    nchar(area_fips) == 4 ~ paste("0", area_fips, sep = ""), 
    TRUE ~ area_fips
  ))

states <- data.frame(state_abbr = state.abb, area_title = state.name)

area_codes <- left_join(area_codes, states) %>% 
  mutate(state_abbr = case_when(
    area_title == "District of Columbia" ~ "DC",
    area_title == "Puerto Rico" ~ "PR",
    TRUE ~ state_abbr))
```


```{r}
ExpandColorsLIGHT <- function(colors, n, steps = 11){
  if(n <= steps){
    suppressWarnings({
      sapply(colors, function(x){colorRampPalette(c(x, "#FFFFFF"))(steps)}) %>% 
        as.data.frame() %>% 
        filter(row_number() <= n) %>% 
        gather(key = original.color, value = expanded.color)
    })
  }else{
    warning("Select n < steps!")
  }
}
```


```{r}
ExpandColorsDARK <- function(colors, n, steps = 11){
  if(n <= steps){
    suppressWarnings({
      sapply(colors, function(x){colorRampPalette(c(x, "#000000"))(steps)}) %>% 
        as.data.frame() %>% 
        filter(row_number() <= n) %>% 
        gather(key = original.color, value = expanded.color)
    })
  }else{
    warning("Select n < steps!")
  }
}
```

```{r, include = FALSE}
#Map Data
county_sf <- counties(cb = TRUE) %>% 
  shift_geometry(position = "outside")
states_sf <- states(cb = TRUE, resolution = "20m") %>%
  shift_geometry(position = "outside")
```

```{r, include = FALSE}
#Change projection of data for leaflet

states_leaflet <- states_sf %>% 
  sf::st_transform('+proj=longlat +datum=WGS84')

counties_leaflet <- county_sf %>% 
  sf::st_transform('+proj=longlat +datum=WGS84') 
```

```{r, include = FALSE}
#Convert county data to a table
county_data <- counties_leaflet %>% 
  as_tibble() %>% 
  select(STATEFP, COUNTYFP, AFFGEOID) %>% 
  mutate(area_fips = paste(STATEFP, COUNTYFP, sep = ""), 
         st = as.numeric(STATEFP))
```


```{r, include = FALSE}
#Get center of each county
county_centers <- counties_leaflet %>% 
  filter(str_detect(NAME, "Mariana", negate = TRUE)) %>% 
  st_centroid() %>% 
  sf::st_transform('+proj=longlat +datum=WGS84')
```

```{r, include = FALSE}
#Load Existing Data
qcew_3digits <- readRDS(here("State Data/qcew_3digit.RDS")) %>% 
  mutate(industry_desc = substring(industry_title, 11))
```

```{r, include = FALSE}
#Simplify to get industry codes
ind_3digit <- qcew_3digits %>% 
  select(naics_3digit = ind_code, naics_3digit_label = industry_desc) %>% 
  distinct() %>% 
  arrange(naics_3digit_label)
```

```{r, include = FALSE}
#Define colors 
emp_ind_vector <- c(brewer.pal(9, "Greys")[4], "#cf4633", "#BEAED4", "#FDC086", "#FDBF6F",  "#386CB0", "#FB8072", brewer.pal(9, "Greys")[3], brewer.pal(9, "Greys")[8], "#80B1D3", "#F0027F",  "#4DAF4A", "#F1E2CC", "#6A3D9A", "#E78AC3", "#CBD5E8", "#666666", brewer.pal(9, "Greys")[5],  brewer.pal(9, "Greys")[6], "#A65628", brewer.pal(9, "Greys")[7])
```

```{r}
#create data frame mapping colors to industries
col_map <- data.frame(ind_3digit$naics_3digit_label, emp_ind_vector)
```

```{r}
rd_col <- data.frame(ind_3digit.naics_3digit_label = "Scientific R&D", emp_ind_vector = "#8DD3C7")
```

```{r}
col_map <- bind_rows(col_map, rd_col)
```


```{r}
# Map 3-digit NAICS to 3-digit Colors
get_col_vec <- function(data){ 
  data %>% 
    select(naics_3digit_label) %>% 
    distinct() %>% 
    unlist()
  }
```

```{r}
#Function to get appropriate 3-digit colors
get_col_match <- function(data){ 
  
 col_vec <- get_col_vec(data)
 
 col_out <- col_map %>% 
   filter(ind_3digit.naics_3digit_label %in% col_vec) %>% 
   select(emp_ind_vector) %>% 
   unlist() %>% 
   unname()
 
  return(col_out)
  
}
```

```{r}
#Get County GEOIDS and crosswalks
cbp_geoid <- read.csv(here("County Data/5_digit_naics_2019.csv")) %>% 
  mutate(area_fips = str_sub(GEO_ID, -5)) %>% 
  select(GEO_ID, NAME, area_fips) %>% distinct()

cbp_empzes <- read.csv(here("County Data/5_digit_naics_2019.csv")) %>% 
  select(EMPSZES_LABEL, EMPSZES) %>% 
  distinct()

cbp_io <- readRDS(here("Input Output Data/cbp_manf_IO_crosswalk.RDS")) 
```


```{r, include = FALSE}
#read county-level manufacturing data
cbp_2019 <- read.csv(here("County Data/6_digit_naics_CBP.csv")) %>% 
  left_join(cbp_geoid) %>% 
  left_join(county_data) %>% 
  left_join(area_codes %>% select(st, state_abbr)) %>% 
  mutate(across(.cols = c(EMP, ESTAB), ~ gsub(",", "", .)),
    emp_num = as.numeric(EMP), 
    ESTAB = as.numeric(ESTAB)) %>% 
  filter(str_detect(NAME, "Mariana", negate = TRUE)) %>% 
  left_join(cbp_empzes)
```


```{r}
cbp_2019_all <- read.csv(here("County Data/total_naics_2019.csv")) %>% 
  mutate(across(.cols = c(EMP, ESTAB), ~ gsub(",", "", .)),
    tot_emp = as.numeric(EMP), 
    tot_estab = as.numeric(ESTAB)) %>% 
  filter(str_detect(NAME, "Mariana", negate = TRUE), EMPSZES_LABEL == "All establishments") %>% 
  mutate(geo_merge = NAME) %>% 
  left_join(counties_leaflet %>% 
              mutate(geo_merge = paste(NAMELSAD, STATE_NAME, sep = ", ")) %>% 
              rename(county_name = NAME))
```



```{r}
#read Input Output Data
use_table_final <- readRDS(here("Input Output Data/use_table_final.RDS"))
sup_com_agg <- readRDS(here("Input Output Data/sup_com_agg.RDS"))
ind_agg <- readRDS(here("Input Output Data/ind_agg.RDS"))
com_agg <- readRDS(here("Input Output Data/com_agg.RDS"))
supply_table_final <- readRDS(here("Input Output Data/supply_table_final.RDS"))
```


```{r}
#Read NAICS Codes
naics_codes <- read.csv(here("NAICS/naics_codes.csv")) %>% 
  select(c(2,3))

colnames(naics_codes) <- c("industry_code", "industry_desc")
```

```{r, include = FALSE}
naics_2 <- naics_codes %>% 
  filter(str_length(industry_code) == 2 | industry_code == "31-33") %>% 
  mutate(industry_code = case_when(
    industry_code == "31-33" ~ 31.33, 
    TRUE ~ as.numeric(industry_code)
  ))
```

```{r}
naics_sub <- function(var, num){
   as.numeric(str_sub({{ var }}, 1, num))
}
```

# Overview

This document performs a geospatial mapping of manufacturing activity based on shared use and supply of various commodities. This analysis updates and incorporates existing industrial clustering algorithms to provide a new perspective on the geographic and sectoral organization of manufacturing activity in 2019 across the United States.

# Connecting Use and Supply 

## Theoretical Background

The connection of use and supply tables is a complicated task. Extensive work has been done using Input-Output tables to identify national clusters of US industries (Delgado and Mills, 2020; Delgado et al., 2014; Feser and Bergman, 2010), deriving between 22 and 28 unique clusters (on the order of magnitude of 3-digit NAICS manufacturing codes), but little work has been done to identify how the use and supply of commodities by industries might vary geographically. Because previous work has been focused on understanding how industries are connected in general, they chose not to focus on regional variation in the use and supply of commodities. I leverage the fact that industries are sparsely and endogenously distributed across the United States to highlight new geographic and sectoral patterns in the structure and composition of contemporary manufacturing activity. 

The 2017 Input-Output Accounts Data cover the domestic supply and use of commodities by 405 industries. These data provide the dollar value of the output and use of commodities. The lack of quantity information certainly complicates this analysis, as certain commodities are per-unit more valuable. However, these data still provide a baseline for estimating linkages between industries sectors. 

For a given industry $i$, let $C_i$ be the vector of commodities that industry i purchases as intermediate inputs (minus imports). Let $P_i$ be the vector of commodities that industry $i$ outputs (minus exports). Adding imports and exports is saved as a robustness check. I adapt and extend the approach used by Fraser and Bergman, 2000. 

Let $X_{C_i}$ be a matrix with columns representing industries and rows representing the value of the commodities that these industries purchase. Focusing on the manufacturing sector, the input-output use table results in a 232x326 matrix of 232 manufacturing industries (i), and their use of 326 commodities (c).  The first measure I define is $x_{i,c}$: the value of commodity c as an intermediate input in industry i over the total value of intermediate inputs used by industry $i$: $\frac{i_p}{i_{int}}$

Performing correlation analysis, I define $r(x_i, x_j)$, which measures the degree to which industries $i$ and $j$ have similar input purchasing patterns. 

Let $Y_{P_i}$ then be a matrix with columns representing industries and the rows representing the value of the commodities that these industries output. Focusing on the the manufacturing sector, the input-output supply table data results in a 232x255 matrix of 232 manufacturing industries (i), and their output of 255 commodities (c). NAICS codes inherently capture $r(y_i, y_j)$: the measure of the degree to which industries $i$ and $j$ and similar output patterns. However, I formalize this by defining $y_{p, i}$ as the value of production of commodity p as a share of the total value of output by industry $i$:  $\frac{p_i}{p_{tot}}$. This measure can alternatively be calculated as the value of production of commodity p by industry i as a share of total production of commodity p. Let this alternative calculation be denoted by $y_{i, p}$

Neither of these measures, however, captures how industries are inherently linked together. Unfortunately, data in the 2017 supply table do not differentiate production for use an intermediate input from production as a final output. For example, the value of use of Scientific R&D as an input is just over \$12,000, but the value of output of scientific R&D as a commodity is over \$650,000. Fortunately, not every product is used as an intermediary product. Let $\lambda_c = c_{int} / c_{tot}$ be the share of the value of the total output of commodity c that is used as an intermediate input. 

I construct a matrix $M_{i,j}$, with each column denoting the vector of industries $j$ that supply $i$. An in this matrix, for given industries $i$ and $j$ is constructed as follows. 

For all commodities that industry $j$ outputs, let $m_{i,j}$ be the sum over the products that industry $j$ outputs ($p_{i,j}$) that belong to the set of commodities $C_i$, of: the commodities that industry $i$ uses as intermediate inputs, the share of the value of the total output of commodity p that is used as an intermediate input ($\lambda_p$), and the value of commodity p as an intermediate input in industry i over the total value of intermediate inputs used by industry $i$. 

$$m_{i,j} = \sum_{P_c \in C_i} Y_{j,p}*\lambda_p * x_{i,p} = \sum_{P_c \in C_i} \frac{p_j}{p_{tot}}*\frac{p_{int}}{p_{tot}} * \frac{i_p}{i_{int}}$$

Thus, the vector $m_i$ captures the intensity of supply to industry $i$ that each other industry $j$ consists of. This measure could technically be abstracted one level further, to consider the degree to which an industry $j$ supplies to other industries $l$ that industry $i$ uses as its main suppliers. This calculation is also saved as a robustness check. 

With this specification, a given industry $j$ is considered a supplier of industry $i$ if $m_{ij}$ is above some threshold.

## Implementation

The above calculations can be constructed with the following datasets: the final use table, the final supply table, the industry aggregate table, and the commodity aggregate table. The construction of these datasets are provided in the input_output.rmd cleaning file. 

I make some initial cleaning adjustments to some of these tables to begin. 

```{r}
#Take the aggregate industry output measures and summarize them. 
manf_ind <- ind_agg %>% 
  mutate(naics_3digit = as.numeric(str_sub(industry_code, 1, 3))) %>% 
  left_join(ind_3digit) %>% 
  filter(naics_3digit >= 300 & naics_3digit < 400) %>% 
  #FIX MISSING VALUES WITH 0
  mutate(across(.cols = c(3:7), ~ case_when(
    is.na(.) ~ 0, 
    TRUE ~ .)), 
    log_ind = log(industry_output), 
    log_value = log(value_added), 
    log_inputs = log(intermediary_inputs), 
    val_ratio = value_added/industry_output, 
    input_ratio = intermediary_inputs/industry_output, 
    log_imports = log(imports), 
    import_ratio = imports/intermediary_inputs) 
```


### Inputs 

```{r}
#focus on manufacturing sector, join with manufacturing aggregate and create share
manf_inputs <- use_table_final %>% 
  filter(naics_3digit >= 300 & naics_3digit < 400) %>% 
  select(-c(value, value_clean)) %>% 
  left_join(manf_ind) %>% 
  mutate(input_share = value_num / intermediary_inputs) %>% 
  ungroup() %>% 
  arrange(industry_code)
```

```{r}
ind_crosswalk <- manf_inputs %>% 
  ungroup() %>% 
  select(industry_code, industry_desc, naics_3digit, naics_3digit_label) %>% 
  distinct() %>% 
  mutate(index = seq(n()))
```

```{r}
saveRDS(ind_crosswalk, here("Input Output Data/ind_crosswalk.RDS"))
```


```{r}
com_list <- manf_inputs %>% 
  select(commodity_code) %>% 
  distinct() %>% 
  unlist() %>% 
  unname()
```

```{r}
ind_list <- manf_inputs %>% 
  select(industry_code) %>% 
  distinct() %>% 
  unlist() %>% 
  unname()
```

Here, the individual row entries of the matrix $X_{C_i}$ are given by the value of each $x_{i,c}$. I create a 232x326 matrix of 232 manufacturing industries (i), and their use of 326 commodities (c).  

```{r}
#create wide dataframe with each row being an industry and each column being a commodity 
input_cluster_raw <- manf_inputs %>% 
  select(commodity_code, commodity_desc, industry_desc, industry_code, value_num, input_share) %>% 
  pivot_wider(id_cols = c(industry_desc, industry_code), values_from = value_num, names_from = commodity_code, values_fill = 0) 

input_cluster_share <- manf_inputs %>% 
  select(commodity_code, commodity_desc, industry_desc, industry_code, value_num, input_share) %>% 
  pivot_wider(id_cols = c(industry_desc, industry_code), values_from = input_share, names_from = commodity_code, values_fill = 0)
```


```{r}
input_matrix <- input_cluster_share %>% 
  select(-c(industry_code, industry_desc)) %>% 
  as.matrix()

input_matrix_raw <- input_cluster_raw %>% 
  select(-c(industry_code, industry_desc)) %>% 
  as.matrix()
```

### Lambda_C

At this point, I construct $\lambda_c$. 

```{r}
lambda_c <- com_agg %>% 
  filter(commodity_code %in% com_list) %>% 
  mutate(com_share = intermediate / total_use) %>% 
  select(com_share, commodity_code)
```

So far, calculations have all been done with the use database. Introducing the supply of commodities requires a different database. 

### Outputs

```{r}
manf_supply <- supply_table_final %>% 
  filter(naics_3digit >= 300 & naics_3digit < 400) %>% 
  left_join(sup_com_agg) %>% 
  mutate(manf_percent = value_num / commodity_output_raw) %>% #percentage of a given output that is manufactured by a given manufacturing industry
  left_join(ind_agg) %>% 
  mutate(supply_percent = value_num / industry_output) %>%  #percentage of total industry supply that a given output makes up
  group_by(industry_code) %>% 
  mutate(prod_num = n(), #Number of total products an industry produces 
         main_prod = max(supply_percent, na.rm = TRUE),
         manf_sup = manf_percent*supply_percent) %>% #Across all commodities an industry produces, the maximum of the percentage of total industry supply a given output makes up
  arrange(industry_code) %>% 
  ungroup()
```


```{r}
#list of goods made by the manufacturing industry
com_code_list <- manf_supply %>% 
  ungroup() %>% 
  select(commodity_code) %>% 
  distinct() %>% 
  unlist() %>% 
  unname()
```

I now create a 232 x 254 matrix, with the rows being individual industries, and columns being the commodities that industry outputs. The column number is indexed by a list of all commodity codes. 

```{r}
output_clustering <- manf_supply %>% 
  ungroup() %>% 
  select(commodity_code, commodity_desc, industry_desc, industry_code, value_num, manf_percent, supply_percent, manf_sup) %>% 
  pivot_wider(id_cols = c(industry_desc, industry_code), values_from = manf_percent, names_from = commodity_code, values_fill = 0) 
```

```{r}
output_matrix_raw <- output_clustering %>% 
  ungroup() %>% 
  select(-c(industry_desc, industry_code)) %>% 
  as.matrix()
```

### Final Analysis

There are three different measures of interest to create. 

1) Input Correlation (how industries use similar inputs)
2) Output Correlation (how industries produce similar outputs)
3) Supply of Inputs (how industries produce outputs used as inputs by other industries)

In this section, I create each of these measures. 

```{r}
mat_holder <- matrix(0, 232, 232)
```

#### Semiconductor Case Study

Consider the case of the semiconductor and related devices manufacturing industry, industry 334413. This industry uses 109 different inputs, the majority of which come from semiconductor and related industries, and the next highest of which come from nonferrous metal manufacturing. 

```{r}
#Get Subset of Commodities used by Industry i
industry_inputs <- manf_inputs %>% 
    filter(industry_code %in% c("334413"), value_num > 0) 
```

```{r}
#Get List of Commodities used by industry I
input_list <- industry_inputs$commodity_code
```

```{r}
#Get Index for Inputs used by industry i
inputs_used <- which(com_list %in% input_list)
```

Other manufacturing industries vary in their use of similar inputs. The total share of intermediary inputs accounted for by the subset of inputs used by industry i varies substantially, and can be calculated.  

```{r}
#Create Subset of Inputs Matrix of use of the set of commodities used by i
input_results <- input_matrix[, inputs_used] %>% as.matrix()
```

```{r}
#Sum Use of Subset of Products
input_sums <- input_results %>% rowSums()
```

```{r}
#Create Dataframe of related industries
related_ind <- data.frame(input_results) %>% 
  mutate(ind_i = ind_list,
    row_sums = input_sums) %>% 
  select(row_sums, ind_i, everything())
```

```{r}
#To populate a non-missing graph, need at least 3 observations
rel_ind_clean <- related_ind %>% 
  select(row_sums, industry_code = ind_i) %>% 
  left_join(ind_crosswalk) %>% 
  group_by(naics_3digit_label) %>% mutate(count = n()) %>% filter(count > 3) %>% 
  ungroup()

rel_ind_col <- get_col_match(rel_ind_clean)

related_industries_graph <- rel_ind_clean %>% 
  ggplot(aes(x = row_sums, y = naics_3digit_label, fill = factor(naics_3digit_label))) + 
  geom_density_ridges(aes(), alpha = 0.7, jittered_points = TRUE, point_alpha=1,point_shape=21) + 
  scale_fill_manual(values = rel_ind_col) + 
  guides(fill = "none") + 
  labs(x = "Total Share of Industry Intermediate Input in Supplied Commodities", y = 
         "NAICS 3-digit Summary") + 
  theme_bw() + 
  axis_theme

related_industries_graph
```

I apply a cutoff of 50%, and filter for industries that can account for at least 50% of their total use of intermediate inputs from the set of inputs used by industry i, leaving a total of 161 manufacturing industries (from an initial set of 232). 

```{r}
#Get list of related industries
input_sum_check = related_ind %>% 
  filter(ind_i == "334413") %>% 
  select(row_sums) %>% 
  unlist() %>% 
  unname()

rel_ind <- related_ind %>% 
  filter(row_sums > (.5*input_sum_check)) 
```

```{r}
#Get index of related industries
rel_ind_index <- which(ind_list %in% rel_ind$ind_i) 
```

```{r}
#Final Matrix
rel_ind_matrix <- input_matrix[rel_ind_index, ]
```

```{r}
rel_ind_raw <- input_matrix_raw[rel_ind_index, ]
```

```{r}
#Index Industry I 
ind_index <- rel_ind %>% 
  mutate(tal = seq(n())) %>%
  filter(ind_i == "334413") %>% 
  select(ind_i, tal)
```

The above matrix $X_{C_i}$ details the share of the value of total intermediate inputs used by each industry that comes from each commodity $c$, across the subset of industries that get at least 50% of their total value of intermediate inputs from the set of inputs used by industry i. I calculate the correlation between a specific industry $i$'s input vector, and other industries input vectors as well. Here, the goal is to identify the subset of other industries that are most similar to industry $i$ in their use of the set of commodities used by manufacturing sector $i$.

##### Measures of Correlation

There are multiple different ways to measure correlation. In this case, we are interested in measuring correlations across industries, and can either measure correlation across a subset of industries that are somehow related to the target industry (e.g through use of common inputs or production of common outputs), or across the entire universe of industries. Here, I compare the results for these different approaches as they pertain to the semiconductor manufacturing industry. 

```{r}
#define function to calculate correlation for a subset of industries 
make_cor_matrix <- function(rel_matrix, industry, method){
  
  cor_mes <- as.dist(cor(t(rel_matrix), method = c(method))) %>% as.matrix()
  
  ind_cor_df <- data.frame(industry_code = rel_ind$ind_i, industry_cor = cor_mes[ind_index$tal,]) %>%
  right_join(ind_crosswalk) %>% 
  mutate(industry_i = industry)
  
  return(ind_cor_df)
}
```

```{r}
#define function to calculate correlation over all industries 
make_cor_matrix_raw <- function(rel_matrix, industry, method){
  
  cor_mes <- as.dist(cor(t(rel_matrix), method = c(method))) %>% as.matrix()
  
  ind_cor_df <- data.frame(industry_code = related_ind$ind_i, industry_cor = cor_mes[ind_index$tal,]) %>%
  right_join(ind_crosswalk) %>% 
  mutate(industry_i = industry)
  
  return(ind_cor_df)
}
```


```{r}
#get list of inputs used by a target industry
compare_inputs <- function(industry){ 
  
  manf_inputs %>% 
    filter(industry_code == industry) %>% 
    mutate(input_share = value_num / intermediary_inputs) %>% select(commodity_desc, value_num, input_share) 
  
  }
```


```{r}
semi_inputs <- compare_inputs("334413")
```

```{r}
#Pearson tests on share and value

test1 <- make_cor_matrix(rel_ind_matrix, "334413", "pearson") #this one wins
test2 <- make_cor_matrix_raw(input_matrix, "334413", "pearson")

test3 <- make_cor_matrix(rel_ind_raw, "334413", "pearson")
test4 <- make_cor_matrix_raw(input_matrix_raw, "334413", "pearson")
```


```{r}
#Pearson v. Spearman tests, note raw v share  does not matter for spearman because it is a rank based calculation

ps_test1 <- make_cor_matrix(rel_ind_matrix, "334413", "spearman") #this one is the winner so far!!! 
ps_test2 <- make_cor_matrix_raw(input_matrix, "334413", "spearman")

```

Based on a manual examination of the different outputs, I calculate the spearman correaltion coefficient over a subset of related industries (defined in this case as getting at least 50% of the value of their use of intermediate inputs from the set of inputs used by the target industry). 

##### Final Input Results

```{r}
#Get Correlation
ind_cor <- as.dist(cor(t(rel_ind_matrix), method = c("spearman"))) %>% as.matrix()
```


```{r}
#Build Final Correlation Dataframe
ind_cor_df <- data.frame(industry_code = rel_ind$ind_i, industry_cor = ind_cor[ind_index$tal,]) %>%
  right_join(ind_crosswalk) %>% 
  mutate(industry_i = "334413")
```

```{r}
#Replace Industry I Code from 0 to 1
ind_cor_df$industry_cor[ind_cor_df$industry_code == ind_index$ind_i] = 1
```


This final dataframe tells as about the similarity in use of inputs across somewhat related industries, and leaves missing values for industries that do not share some common use of inputs. 

```{r}
ind_cor_clean <- ind_cor_df %>% 
  select(industry_cor, industry_code) %>% 
  left_join(ind_crosswalk) %>% 
  group_by(naics_3digit_label) %>% mutate(count = n()) %>% filter(count > 3, !is.na(industry_cor)) %>% 
  ungroup()

ind_cor_col <- get_col_match(ind_cor_clean)

ind_cor_clean_graph <- ind_cor_clean %>% 
  ggplot(aes(x = industry_cor, y = naics_3digit_label, fill = naics_3digit_label)) + 
  geom_density_ridges(aes(), alpha = 0.7, jittered_points = TRUE, point_alpha=1,point_shape=21) + 
  scale_fill_manual(values = ind_cor_col) + 
  guides(fill = "none") + 
  labs(x = "Correlation in Input Vector with Industry I", y = 
         "NAICS 3-digit Summary") + 
  theme_bw() + 
  axis_theme

ind_cor_clean_graph
```


### Generalized Input Correlations 

This above procedure must then be repeated many times, over the entire set of industries.  

```{r}
get_input_results <- function(industry){ 

  
  #Get List of Inputs for a specific industry I 
  industry_inputs <- manf_inputs %>% 
    filter(industry_code %in% industry, value_num > 0) 
  
  #Get List of Commodities used by industry I
  input_list <- industry_inputs$commodity_code
  #Get Index for Inputs used by industry i
  inputs_used <- which(com_list %in% input_list)
  
  #Create Subset of Inputs Matrix of use of the set of commodities used by i
  input_results <- input_matrix[, inputs_used] %>% as.matrix()
  #Sum Use of Subset of Products
  input_sums <- input_results %>% rowSums()
  
  #Create Dataframe of related industries
  related_ind <- data.frame(input_results) %>% 
    mutate(ind_i = ind_list,
      row_sums = input_sums) %>% 
    select(row_sums, ind_i, everything())
  
  #Get list of related industries
  input_sum_check = related_ind %>% 
    filter(ind_i == industry) %>% 
    select(row_sums) %>% 
    unlist() %>% 
    unname()

  rel_ind <- related_ind %>% 
  filter(row_sums > (.5*input_sum_check)) 
  
  #NOTE: for a very few industries, not all of the intermediate inputs used are accounted for by the list of commodities (perhaps some of the intermediate inputs are scrap?). As such, the threshold we use is .50 of the maximum value of total commmodities used as inputs. 
  
  #Get index of related industries
  rel_ind_index <- which(ind_list %in% rel_ind$ind_i) 
  #Final Matrix
  rel_ind_matrix <- input_matrix[rel_ind_index, ]
  
  #Get Correlation
  ind_cor <- as.dist(cor(t(rel_ind_matrix), method = c("spearman"))) %>% as.matrix()
  #Index Industry I 
  ind_index <- rel_ind %>% 
    mutate(tal = seq(n())) %>%
    filter(ind_i == industry) %>% 
    select(ind_i, tal)
  #Build Final Correlation Dataframe
  ind_cor_df <- data.frame(industry_code = rel_ind$ind_i, industry_cor = ind_cor[ind_index$tal,]) %>%
    right_join(ind_crosswalk) %>% 
    mutate(industry_i = industry)
  
  #Replace Industry I Code from 0 to 1
  ind_cor_df$industry_cor[ind_cor_df$industry_code == ind_index$ind_i] = 1

  return(ind_cor_df)
  
  }
```

```{r}
ind_cor_holder <- ind_cor_df[0,]

for (i in ind_list){
  #print(i)
  ind_cor_holder <- bind_rows(ind_cor_holder, get_input_results(i))
  
}

```

```{r}
input_results_final <- ind_cor_holder
```

```{r}
saveRDS(input_results_final, here("Input Output Data/input_results.RDS"))
```

### Production of Outputs

I now turn to measuring the output correlation between industries. In a way, output correlations are reflected in NAICS groupings; however, we do not have a way to capture the correlation between industries easily. As such, in this section, I construct a measure of output correlations. 

Again, let us consider the case of the semi-conductor industry. 

```{r}
#Get Subset of Commodities produced by Industry i
industry_outputs <- manf_supply %>% 
    filter(industry_code %in% c("334413"), value_num > 0) 
```


```{r}
com_list_out <- manf_supply %>% 
  ungroup() %>% 
  select(commodity_code) %>% 
  distinct() %>% 
  unlist() %>% 
  unname()
```

```{r}
#Get List of Commodities produced by industry I
output_list <- industry_outputs$commodity_code
```

```{r}
#Get Index for outputs made by industry i
outputs_made <- which(com_list_out %in% output_list)
```

Other manufacturing industries vary in their production of similar outputs. 

```{r}
#Create Subset of Output Matrix of the production of commodities by i
output_results <- output_matrix_raw[, outputs_made] %>% as.matrix()
```

```{r}
#Sum of Production of products
output_sums <- input_results %>% rowSums()
```

```{r}
#Create Dataframe of related industries
output_related_ind <- data.frame(output_results) %>% 
  mutate(ind_i = ind_list,
    row_sums = output_sums) %>% 
  select(row_sums, ind_i, everything())
```

```{r}
#To populate a non-missing graph, need at least 3 observations
output_rel_ind_clean <- output_related_ind %>% 
  select(row_sums, industry_code = ind_i) %>% 
  left_join(ind_crosswalk) %>% 
  group_by(naics_3digit_label) %>% mutate(count = n()) %>% filter(count > 3) %>% 
  ungroup()

out_rel_ind_col <- get_col_match(output_rel_ind_clean)

output_related_industries_graph <- output_rel_ind_clean %>% 
  ggplot(aes(x = row_sums, y = naics_3digit_label, fill = factor(naics_3digit_label))) + 
  geom_density_ridges(aes(), alpha = 0.7, jittered_points = TRUE, point_alpha=1,point_shape=21) + 
  scale_fill_manual(values = rel_ind_col) + 
  guides(fill = "none") + 
  labs(x = "Total Share of Industry Intermediate Input in Supplied Commodities", y = 
         "NAICS 3-digit Summary") + 
  theme_bw() + 
  axis_theme

output_related_industries_graph
```

I apply a cutoff of 40%, and filter for industries that can account for at least 50% of their value of outputs produced that comes from the semiconductor and related devices manufacturing sector. 

```{r}
#Get list of related industries
output_sum_check = output_related_ind %>% 
  filter(ind_i == "334413") %>% 
  select(row_sums) %>% 
  unlist() %>% 
  unname()

output_rel_ind <- output_related_ind %>% 
  filter(row_sums > (.4*output_sum_check)) 
```

```{r}
#Get index of related industries
op_rel_ind_index <- which(ind_list %in% output_rel_ind$ind_i) 
```

```{r}
#Final Matrix
op_rel_ind_matrix <- output_matrix_raw[op_rel_ind_index, ] 
```


```{r}
#Index Industry I 
op_ind_index <- output_rel_ind %>% 
  mutate(tal = seq(n())) %>%
  filter(ind_i == "334413") %>% 
  select(ind_i, tal)
```

For consistency, I use the spearmans correlation over the set of industries that have at least 40% of their value in production of goods produced by industry i. 


```{r}
#Get Correlation
op_ind_cor <- as.dist(cor(t(op_rel_ind_matrix), method = c("spearman"))) %>% as.matrix()
```


```{r}
#Build Final Correlation Dataframe
op_ind_cor_df <- data.frame(industry_code = output_rel_ind$ind_i, industry_cor = op_ind_cor[op_ind_index$tal,]) %>%
  right_join(ind_crosswalk) %>% 
  mutate(industry_i = "334413")
```

```{r}
#Replace Industry I Code from 0 to 1
op_ind_cor_df$industry_cor[op_ind_cor_df$industry_code == op_ind_index$ind_i] = 1
```

This final dataframe tells as about the similarity in use of inputs across somewhat related industries, and leaves missing values for industries that do not share some common use of inputs. 

```{r}
op_ind_cor_clean <- op_ind_cor_df %>% 
  select(industry_cor, industry_code) %>% 
  left_join(ind_crosswalk) %>% 
  group_by(naics_3digit_label) %>% mutate(count = n()) %>% filter(count > 3, !is.na(industry_cor)) %>% 
  ungroup()

op_ind_cor_col <- get_col_match(op_ind_cor_clean)

op_ind_cor_clean_graph <- op_ind_cor_clean %>% 
  ggplot(aes(x = industry_cor, y = naics_3digit_label, fill = naics_3digit_label)) + 
  geom_density_ridges(aes(), alpha = 0.7, jittered_points = TRUE, point_alpha=1,point_shape=21) + 
  scale_fill_manual(values = ind_cor_col) + 
  guides(fill = "none") + 
  labs(x = "Correlation in Input Vector with Industry I", y = 
         "NAICS 3-digit Summary") + 
  theme_bw() + 
  axis_theme

op_ind_cor_clean_graph
```

### Generalized Output Correlations 

This above procedure must then be repeated many times, over the entire set of industries.  

```{r}
get_output_results <- function(industry){ 

  
  #Get List of Inputs for a specific industry I 
  industry_outputs <- manf_supply %>% 
    filter(industry_code %in% industry, value_num > 0) 
  
  #Get List of Commodities used by industry I
  output_list <- industry_outputs$commodity_code
  #Get Index for Inputs used by industry i
  outputs_made <- which(com_list_out %in% input_list)
  
  #Create Subset of Inputs Matrix of use of the set of commodities used by i
  output_results <- output_matrix_raw[, outputs_made] %>% as.matrix()
  #Sum Use of Subset of Products
  output_sums <- output_results %>% rowSums()
  
  #Create Dataframe of related industries
  op_related_ind <- data.frame(output_results) %>% 
    mutate(ind_i = ind_list,
      row_sums = input_sums) %>% 
    select(row_sums, ind_i, everything())
  
  #Get list of related industries
  op_sum_check = op_related_ind %>% 
    filter(ind_i == industry) %>% 
    select(row_sums) %>% 
    unlist() %>% 
    unname()

  op_rel_ind <- op_related_ind %>% 
  filter(row_sums > (.4*op_sum_check)) 
  
  #NOTE: for a very few industries, not all of the intermediate inputs used are accounted for by the list of commodities (perhaps some of the intermediate inputs are scrap?). As such, the threshold we use is .50 of the maximum value of total commmodities used as inputs. 
  
  #Get index of related industries
  op_rel_ind_index <- which(ind_list %in% op_rel_ind$ind_i) 
  #Final Matrix
  op_rel_ind_matrix <- output_matrix_raw[op_rel_ind_index, ]
  
  #Get Correlation
  op_ind_cor <- as.dist(cor(t(op_rel_ind_matrix), method = c("spearman"))) %>% as.matrix()
  #Index Industry I 
  op_ind_index <- op_rel_ind %>% 
    mutate(tal = seq(n())) %>%
    filter(ind_i == industry) %>% 
    select(ind_i, tal)
  #Build Final Correlation Dataframe
  op_ind_cor_df <- data.frame(industry_code = op_rel_ind$ind_i, industry_cor = op_ind_cor[op_ind_index$tal,]) %>%
    right_join(ind_crosswalk) %>% 
    mutate(industry_i = industry)
  
  #Replace Industry I Code from 0 to 1
  op_ind_cor_df$industry_cor[op_ind_cor_df$industry_code == op_ind_index$ind_i] = 1

  return(op_ind_cor_df)
  
  }
```

```{r}
op_ind_cor_holder <- op_ind_cor_df[0,]

for (i in ind_list){
  #print(i)
  op_ind_cor_holder <- bind_rows(op_ind_cor_holder, get_output_results(i))
  
}

```

```{r}
output_results_final <- op_ind_cor_holder
```

```{r}
saveRDS(output_results_final, here("Input Output Data/output_results.RDS"))
```


### Supply of Inputs

I conclude by finally combining the supply and use tables together. Taking the matrix of the use of inputs, I multiply this by the transpose of the matrix of the production of outputs, normalized by the commodity input use vector. 

This process must be performed over all industries $i$. Fortunately, the above process covers all possible $j$ for a given industry $i$. I define a function to capture the above process, iterate through every $i$ in the dataset. The output is a final matrix $M_{i,j}$, where each row represents a vector of the industries that supply $i$, and each column represents the vector of industries that are supplied by $i$, populated by a measure of the intensity of supply. In addition, I output a long-formatted dataframe indexing the top 3-most correlated industries in terms of use of similar inputs, for each industry $i$. 


As before, I test this procedure out for the semiconductor and related device manufacturing industry. 

```{r}
industry = "334413"
```

This industry uses a total of 109 commodities. Of these 109 commodities, 73 are produced by the manufacturing sector. 

```{r}
#Get List of Inputs for a specific industry I 
  input_list <- manf_inputs %>% 
    filter(industry_code %in% c(industry), value_num > 0) %>% 
    select(commodity_code) %>% 
    unlist() %>% 
    unname()

#Match the commodity codes to the index of commodity codes we have (supply)
  com_list_sup <- which(com_code_list %in% input_list) %>% 
    unlist() %>% 
    unname()
```

```{r}
#Get the list of supplied commodities
  supplied_commodities <- com_code_list[com_list_sup]
  
  #Get the lambda_c vector
  lambda_inputs <- lambda_c %>% 
      filter(commodity_code %in% supplied_commodities) %>% 
      select(com_share) %>% 
      unlist() %>% 
      unname() 
```

Thus, we can create a matrix that accounts for how other manufacturing industries contribute to the supply of inputs used by industry i. 

```{r}
  #From the matrix of outputs $Y_{P_i}$, extract the columns that correspond to the inputs used by industry $i$. 
  output_matrix <- output_matrix_raw[, com_list_sup] %>% as.matrix()
```


Since not all products are used at the same intensity as intermediary products, we must adjust. 

```{r}
# Perform element wise multiplication across the rows to normalize by use of commodity as an input
  com_adj <- output_matrix*lambda_inputs
```

Focusing in on the subset of commodities used as inputs by industry i, we can define a vector of the intensity of use of various commodities. Multiplying this vector by the matrix of output of commodities used by industry i supplied by the other manufacturing sectors, we arrive at a final vector of the supply of inputs used by industry i by the other manufacturing sectors. 

```{r}
  #Get Index for Supplied Commodities in Input Data
  input_com_list <- which(com_list %in% supplied_commodities) 
  
  #Get Index for Industry I 
  ind_row <- which(ind_list %in% c(industry))
  
  #From the matrix of inputs $X_{C_i}$, extract the input columns that correspond to the inputs used by a given industry I. 
  input_results <- input_matrix[ind_row, input_com_list] %>% as.matrix()
```

```{r}
 supply_results <- t(input_results) %*% t(com_adj)
```

We then manually correct for industries that are deemed to not "substantially supply" the target industries. These industries are defined as industries that on average, contribute less than 1% to the total supply of a given commodity. For these industries, we assign a value of 0. 

```{r}
non_cor_ind <- which(rowMeans(output_matrix) < .01)
```

```{r}
supply_results[, non_cor_ind] = 0 
```


```{r}
#check to make sure this makes sense when applied to shares and not values
get_industry_outputs <- function(industry){
  
  #Get List of Inputs for a specific industry I 
  input_list <- manf_inputs %>% 
    filter(industry_code %in% c(industry), value_num > 0) %>% 
    select(commodity_code) %>% 
    unlist() %>% 
    unname()
  
  
  #Match the commodity codes to the index of commodity codes we have (supply)
  com_list_sup <- which(com_code_list %in% input_list) %>% 
    unlist() %>% 
    unname()
  
  #Get the list of supplied commodities
  supplied_commodities <- com_code_list[com_list_sup]
  
  #Get the lambda_c vector
  lambda_inputs <- lambda_c %>% 
      filter(commodity_code %in% supplied_commodities) %>% 
      select(com_share) %>% 
      unlist() %>% 
      unname() 
  
  #From the matrix of outputs $Y_{P_i}$, extract the columns that correspond to the inputs used by industry $i$. 
  output_matrix <- output_matrix_raw[, com_list_sup] %>% as.matrix()
  
  # Perform element wise multiplication across the rows to normalize by use of commodity as an input
  com_adj <- output_matrix*lambda_inputs
  
  #Get Index for Supplied Commodities in Input Data
  input_com_list <- which(com_list %in% supplied_commodities) 
  
  #Get Index for Industry I 
  ind_row <- which(ind_list %in% c(industry))
  
  #From the matrix of inputs $X_{C_i}$, extract the input columns that correspond to the inputs used by a given industry I. 
  input_results <- input_matrix[ind_row, input_com_list] %>% as.matrix()
  
  #Results vector
  
  supply_results <- t(input_results) %*% t(output_matrix)
  
  non_cor_ind <- which(rowMeans(output_matrix) < .01)
  
  supply_results[, non_cor_ind] = 0 

  
  return(supply_results)
}
```


```{r}
mat_holder <- matrix(0, 232, 232)

for (i in 1:length(ind_list)){

  
  mat_holder[i, ] <- get_industry_outputs(ind_list[i])
  

}
```


```{r}
results_df <- as.data.frame(mat_holder)

colnames(results_df) <- ind_list

results_long <- results_df %>% 
  mutate(industry_i = ind_list) %>% 
  select(industry_i, everything()) %>% 
  pivot_longer( col = -c(industry_i), names_to = "industry_j", values_to = "m_ij")
```

```{r}
saveRDS(mat_holder, here("Input Output Data/results_matrix.RDS"))
```


At the conclusion of this analysis, the input-output tables yield 3 separate measures of how industries are related. I define these matricies now. 


1. $r(x_{i,c}, x_{j,c})$: measures the degree to which industries $i$ and $j$ use the same input mix. This measure captures vertical agglomeration. 

```{r}
input_matrix_final <- input_results_final %>% 
  mutate(industry_cor = case_when(
    is.na(industry_cor) ~ 0, 
    TRUE ~ industry_cor)) %>% 
  select(industry_cor, industry_code, industry_i) %>% 
  pivot_wider(id_cols = industry_i, names_from = industry_code, values_from = industry_cor) %>% 
  select(-c(industry_i))
```


2. $r(y_{i,p}, y_{j,p})$: measures the degree to which industries $i$ and $j$ produce the same output mix, highly correlated with NAICS. This measure captures horizontal agglomeration

```{r}
output_matrix_final <- output_results_final %>% 
  mutate(industry_cor = case_when(
    is.na(industry_cor) ~ 0, 
    TRUE ~ industry_cor)) %>% 
  select(industry_cor, industry_code, industry_i) %>% 
  pivot_wider(id_cols = industry_i, names_from = industry_code, values_from = industry_cor) %>% 
  select(-c(industry_i))
```


3. $r(m_{i,j}, m_{j,i})$ measures the degree to which industries $i$ and $j$ source inputs from similar sets of suppliers. This measures is an improved measure of vertical agglomeration from (1). 


```{r}
M_ij <- mat_holder
```


# From Industries to Geographies

Using the above constructed Input Output Data, I now map the use and supply of commodities by the manufacturing sector to county-level establishments details. The geographic distribution of manufacturing activity is heterogeneous and sparse. Defining the use or supply of a given vector of commodities by industries located in a county requires some measure of the absolute and relative intensity of county-level industrial activity. Following in Delgado et. al, 2014, I use employment and establishments as the main measure of county-level industrial activity. This analysis could easily be extended to use GDP or sales as a measure. 

## Theoretical Background 

The sparse geographic location of 6-digit level manufacturing establishments allows for a careful investigation of the use and supply of commodities by the manufacturing sector. Let $m$ be the total number of manufacturing sub-sectors, and $n$ be the total number of counties across the nation. For each county $g$ and manufacturing sub-sector $i$, let $\phi_{g, i}$ be the share of national sub-sector activity in that county. This measure captures the total concentration of sub-sector activity that occurs in a specific county:

$$\phi_{i,g} = \frac{i_g}{\sum_{i=1}^m i}$$
This measure needs to be modified to account for skews in concentration of certain industries in certain geographies. Fortunately, the location quotient for an industry provides for a standard and useful correction here. The location quotient is defined as the county's share of a specific industry, divided by the average county share for that industry across the nation:

$$LQ_{g,i} = \frac{\phi_{i,g}}{( \frac{1}{n} \sum_{g=1}^{n} \phi_{i,g})}$$


Thus, a measure of industrial activity in a given county can be approximated by: 

$$\tilde{A}_{g,i} = \phi_{i,g} * LQ_{g,i}$$ 

The above Input-Output section maps industry activity to the production and use of specific vectors of commodities. As such, I do not need to specifically map individual industries to commodities. Instead, I estimate the relatedness between a specific manufacturing sub-sector $i_g$ and the manufacturing sub-sectors located within a specific distance from that sub-sector as a function of that county's industrial activity in a given sub-sector, $\tilde{A}_{g,i}$, and the derived input-output measure of the relatedness between geographically differentiated manufacturing sub-sectors $i_g$ and $j_g$, for all $j_g$ within a specific radius of the county of interest (let the set of these counties and industries be given by $\theta$). 

$$\tilde{A}_{g,i}*r(i_g, j_g \forall g \in \theta)$$

This specification allows for testing the robustness of this analysis to different geographic thresholds of distance (such as defined by commute patterns), as well as different thresholds for industrial measures of relatedness. However, it also allows for the plotting of raw values of industrial relatedness based on geographic distances. 

## Implementation

I turn to the implementation of the above measures across 2019 County Business Pattern Data, with 2017 Input Output Accounts Data. The goal of this section of analysis is to derive three specific measures for each county-subsector pairing that measure the three types of relatedness between industries derived from the input-output data. 

Input-Output Data accounts aggregate NAICS codes at a slightly different level than the CBP does. I use a crosswalk between the CBP NAICS codes and the Input-Output NAICS codes. The standard definition for industries will generally be the IO NAICS code definition. For the purposes of this analysis, I do not differentiate by the establishment sizes in each county and sub-sector, and instead look across all establishments. I create two measures: one that retains the granularity of the original NAICS weighting, and one that aggregates over industry codes available in the input-output data tables. 

```{r}
cbp_merge <- cbp_2019 %>% 
  filter(EMPSZES == 1) %>% 
  left_join(cbp_io) %>% 
  ungroup() %>% 
  group_by(NAICS2017_LABEL) %>% 
  mutate(NAICS_tot_estab_nat = sum(ESTAB), 
         NAICS_tot_emp_nat = sum(emp_num), 
         NAICS_share_emp = emp_num/NAICS_tot_emp_nat, 
         NAICS_share_estab = ESTAB/NAICS_tot_estab_nat) %>% 
  ungroup() %>% 
  mutate(NAICS_estab_lq = NAICS_share_estab / mean(NAICS_share_estab), 
         NAICS_emp_lq = NAICS_share_emp / mean(NAICS_share_emp)) %>% 
  group_by(ind_code, NAME) %>% 
  mutate(county_ind_tot_estabs = sum(ESTAB),
         county_ind_tot_emp = sum(emp_num)) %>% 
  ungroup() %>% 
  group_by(ind_code) %>% 
  mutate(ind_tot_estab_nat = sum(ESTAB), 
         ind_tot_emp_nat = sum(emp_num), 
         ind_share_emp = county_ind_tot_emp/ind_tot_emp_nat, 
         ind_share_estab = county_ind_tot_estabs/ind_tot_estab_nat) %>% 
  ungroup() %>% 
  mutate(ind_estab_lq = ind_share_estab / mean(ind_share_estab), 
         ind_emp_lq = ind_share_emp / mean(ind_share_emp)) %>% 
  group_by(NAME) %>% 
  mutate(county_tot_estabs = sum(ESTAB),
         county_tot_emp = sum(emp_num), 
         county_perc_emp = emp_num / sum(emp_num, na.rm = TRUE), 
         county_perc_estabs = ESTAB / sum(ESTAB, na.rm = TRUE), 
         county_hhi_emp = 1- sum(county_perc_emp**2, na.rm = TRUE), 
         county_hhi_estabs = 1 - sum(county_perc_estabs**2, na.rm = TRUE)) %>% 
  ungroup() 

```


```{r}
cbp_state <- read.csv(here("County Data/state_total_2019.csv")) %>% 
  filter(LFO == 1, EMPSZES == 1) %>% 
  select(area_title = NAME, state_estabs = ESTAB, state_emp = EMP) %>% 
  left_join(area_codes %>% select(-c(area_fips))) %>% 
  filter(!is.na(st))
```

```{r}
cbp_final <- cbp_merge %>% 
  left_join(cbp_state) %>% 
  mutate(NAICS_gi_state_share_emp = emp_num / state_emp, 
         NAICS_gi_state_share_estab = ESTAB / state_estabs, 
         NAICS_a_gi_estabs = NAICS_estab_lq*NAICS_gi_state_share_estab,
         NAICS_a_gi_emp = NAICS_emp_lq*NAICS_gi_state_share_emp,
         ind_gi_state_share_emp = county_ind_tot_emp / state_emp, 
         ind_gi_state_share_estab = county_ind_tot_estabs / state_estabs, 
         ind_a_gi_estabs = ind_estab_lq*ind_gi_state_share_estab,
         ind_a_gi_emp = ind_emp_lq*ind_gi_state_share_emp)
```

```{r}
#Reduce to unique entries for each IO code
cbp_final_io <- cbp_final %>% 
  filter(!is.na(ind_code)) %>% 
  group_by(NAME, ind_code) %>% 
  mutate(tal = seq(n())) %>% 
  filter(tal == 1) %>% 
  ungroup() %>% 
  filter(!is.na(STATEFP)) %>% 
  left_join(cbp_2019_all %>% 
              select(GEO_ID = AFFGEOID, tot_emp, tot_estab))

#NOTE: Not all counties in the US have manufacturing employment. As such, the dataframe cbp_2019_all has more counties than the above dataframe. Manufacturing activity accounts for a small share of establishments. As such, we continue to focus on the manufacturing sector, and do not bring in county level totals for employment and establishments. 
```


This final dataframe contains county-level estimates for $\phi_{i,g}$ as well as $LQ_{g,i}$.I use these variables to calculate $\tilde{A}_{g,i}$. 

I now create a procedure to 1) identify the other industries within a specific county; 2) identify the counties that are located within a specific radius $\theta$ of the county, 3) identifiy the industries that are within these counties, 4) subset the industry relatedness measures with these industries, 5) output a county-sub-sector level score. 

```{r}
#Get dataframe of county centers to merge against
county_centers_cbp <- county_centers %>% 
  rename(GEO_ID = AFFGEOID, state_fips = STATEFP, county_fips = COUNTYFP, county_name = NAME)
```

```{r}
#Merge this with the CBP dataframe
cbp_geog <- cbp_final_io %>% 
  select(-c(STATEFP, COUNTYFP)) %>% 
inner_join(county_centers %>% rename(GEO_ID = AFFGEOID, state_fips = STATEFP, county_fips = COUNTYFP, county_name = NAME), .) 
```

```{r}
#Get ordered list of counties in the dataframe
county_list <- cbp_final_io %>% 
  select(NAME) %>% 
  distinct() %>% 
  unlist() %>% 
  unname()
```

```{r}
# Convert data into 'sf' object
df_sf <- cbp_geog %>% 
    st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326)
```

## Case Study: Los Angeles County, CA 

To build this procedure, I perform a case study analysis of Los Angeles County, which is a fitting example because of the variety of industrial activity that it hosts. The procedure I define will need to both loop through all counties in the data, as well as each sub-sector that is present in the final data. 

```{r}
la <- which(county_list %in% "Los Angeles County, California")
sno <- which(county_list %in% "Snohomish County, Washington")
```

I start by getting the coordinates for the county. 

```{r}
  county_name <- c(county_list[la])
  
  county_ind <- cbp_final_io %>% 
    filter(NAME %in% county_name) %>% 
    arrange(ind_code)
  
  #get list of industries in county
  
  ind_in_county <- county_ind %>% 
    filter(!is.na(ind_code)) %>% 
    select(ind_code) %>% 
    distinct() %>%
    unlist() %>% 
    unname()
  
  county_coords <- county_ind %>% 
    ungroup() %>% 
    select(GEO_ID) %>% 
    distinct() %>% 
    left_join(county_centers_cbp) 
```

Using the geometry object from this point, as well as the county data above, I compute the distance in miles between a given county, and all of the other counties in the dataset. I then merge these data back with specific variables of interest from the CBP data. 

```{r}
# Create the reference 'sf' object
  ref_point_sf <- county_coords$geometry %>% 
    st_coordinates() %>% as.data.frame() %>% 
    st_as_sf(coords = c("X", "Y"), crs = 4326)
  
  # Compute the distance between the reference point and points from 'df_sf'
  results <- st_distance(df_sf, ref_point_sf) %>% 
    set_units("mi") %>% 
    as.data.frame() %>% 
    drop_units() %>% 
    `colnames<-`(., "dist_mi") 
  
  results$NAME <- cbp_geog$NAME
  results$NAICS2017 <- cbp_geog$NAICS2017
  results$NAICS2017_label <- cbp_geog$NAICS2017_LABEL
  results$industry_code <- cbp_geog$ind_code
  results$ind_a_gi_estabs <- cbp_geog$ind_a_gi_estabs
  results$ind_a_gi_emp <- cbp_geog$ind_a_gi_emp
  results$NAICS_a_gi_estabs <- cbp_geog$NAICS_a_gi_estabs
  results$NAICS_a_gi_emp <- cbp_geog$NAICS_a_gi_emp
  results$ind_estabs <- cbp_geog$county_ind_tot_estabs
  results$ind_emp <- cbp_geog$county_ind_tot_emp
  results$county_estabs <- cbp_geog$county_tot_estabs
  results$county_emp <- cbp_geog$county_tot_emp
  results$county_all_estabs <- cbp_geog$tot_estab
  results$county_all_emp <- cbp_geog$tot_emp
  results$county_hhi_emp <- cbp_geog$county_hhi_emp
  results$county_hhi_estabs <- cbp_geog$county_hhi_estabs
```

```{r}
results <- results %>%
  arrange(industry_code)
```

I now establish the set of industries that exist in this county, as well as the set of industries that exist within a specific geographic distance from the main county. 

```{r}
 #Get list of counties and industries within a geographic distance of county and industry i
  geog_ind <- results %>% 
    filter(dist_mi < 100) %>% 
    select(industry_code) %>% 
    distinct() %>% 
    unlist() %>% 
    unname()
```

For each of these industries, iterate over the list of all industries present within the specified geographic distance. To do this, rather than iterate over rows, I leverage the advantages of matrices and matrix multiplication. Using the above data, I create two JxG matrices, one defined by establishments, and one defined by employment, where the rows represent industries, and columns represents industrial activity in a specific county g.

```{r}
county_ind_matrix <-  function(var){
  results %>% 
    filter(dist_mi < 100, !is.na(industry_code)) %>% 
    select(industry_code, NAME, ind_a_gi_emp, ind_a_gi_emp, {{ var }}) %>% 
    distinct() %>% 
    pivot_wider(id_cols = industry_code, names_from = NAME, values_from = {{ var }}, values_fill = 0) %>% 
    select(-c(industry_code)) %>% 
    as.matrix()
} 
```


```{r}
la_list <- results %>% 
    filter(dist_mi < 100, !is.na(industry_code)) %>% 
    select(NAME) %>% 
    distinct() %>% 
  unlist() %>% 
  unname()
```


```{r}
results_ind_emp <- county_ind_matrix(ind_a_gi_emp)

results_ind_estabs <- county_ind_matrix(ind_a_gi_estabs)
```


```{r}
results_estabs <- county_ind_matrix(ind_estabs)
results_emp <- county_ind_matrix(ind_emp)
```

```{r}
#Get County HHI

cnty_hhi_emp <- results %>% 
  filter(NAME %in% county_name) %>% 
  select(county_hhi_emp) %>% 
  distinct() %>% unlist() %>% unname() 

cnty_hhi_estabs <- results %>% 
  filter(NAME %in% county_name) %>% 
  select(county_hhi_estabs) %>% 
  distinct() %>% unlist() %>% unname() 
```


The resulting matrix tells us about the industries that are located within a 100 mile radius of county $g$.

Using the initial list of industries from earlier, I obtain a set of industry relatedness measures from the input output data, focusing on how industries are related to the industry of interest, $i$. I perform this task for each of the input, output, and supply correlation matricies. 

```{r}
#create a helper function
zero_norm <- function(matrix, hhi){ 
  
  matrix_zeros <- matrix %>% 
    proxyC:: rowZeros()
  
  matrix_ratio <- matrix_zeros / length(ind_list_index)
  
  zero_inputs <- which(matrix_ratio == 0)
  
  matrix_ratio[zero_inputs] = 1
  
  final_ratio <- matrix_ratio*hhi
  
  return(final_ratio)
  }
```

```{r}
final_matrix_calc <- function(matrix1, matrix2, hhi){
  
  result1 <- matrix1 %*% matrix2
  
  ratio <- zero_norm(matrix1, hhi)

  output <- rowMeans(result1)*ratio
  
  return(output)
}
```

### Inputs

```{r}
X_ij <- input_matrix_final %>% 
  as.matrix()
```


```{r}
#Use list of industries to get index of industries in relatedness measures
ind_list_index <- which(ind_list %in% geog_ind)

ind_i <- which(geog_ind %in% ind_in_county)
```

We obtain a subset of our input correlation matrix that tells us how the industries within a geographic radius of a focal county are related to one another. 

```{r}
input_agg <- X_ij[ind_list_index, ind_list_index] %>% as.matrix()
```


For each relatedness matrix, I multiply by the geographic matrix defined in the above section.

```{r}
input_agg_emp <- final_matrix_calc(input_agg, results_ind_emp, cnty_hhi_emp)
input_agg_estabs <- final_matrix_calc(input_agg, results_ind_estabs, cnty_hhi_estabs)
```

The resulting vector $\beta_{j,g}$ then has rows defined by the industries related to the target industry $i$, across the counties that are within a specific geographic distance of that county. An individual entry in this matrix is the sum of the geographically weighted correlation between the individual industry $i$ and all other industries in a given county g that falls within some radius of the initial county of interest. 

### Outputs

```{r}
Y_ij <- output_matrix_final %>% 
  as.matrix()
```

We obtain a subset of our output correlation matrix that tells us how the industries within a geographic radius of a focal county are related to one another. 

```{r}
output_agg <- Y_ij[ind_list_index, ind_list_index] %>% as.matrix()
```

For each relatedness matrix, I multiply by the geographic matrix defined in the above section.

```{r}
output_agg_emp <- final_matrix_calc(output_agg, results_ind_emp, cnty_hhi_emp)
output_agg_estabs <- final_matrix_calc(output_agg, results_ind_estabs, cnty_hhi_estabs)
```

### Supply 

We obtain a subset of our supply matrix that tells us how the industries within a geographic radius of a focal county are related to one another. 

```{r}
supply_agg <- M_ij[ind_list_index, ind_list_index] %>% as.matrix()
```

For each relatedness matrix, I multiply by the geographic matrix defined in the above section.

```{r}
supply_agg_emp <- final_matrix_calc(supply_agg, results_ind_emp, cnty_hhi_emp)
supply_agg_estabs <- final_matrix_calc(supply_agg, results_ind_estabs, cnty_hhi_estabs)
```

These values are collected, and then joined back with the initial county-subsector level data. Leveraging the fact that the initial indicies match, this becomes a rather simple task. 

```{r}
other_counties <- results %>% 
  filter(dist_mi < 100, !is.na(industry_code)) %>% 
  select(NAME) %>% 
  unlist() %>% 
  unname()

county_ind_all <- cbp_final_io %>% 
    filter(NAME %in% other_counties) %>% 
    arrange(ind_code)
```


```{r}
county_ind$input_emp <- input_agg_emp
county_ind$input_estabs <- input_agg_estabs
  
county_ind$output_emp <- output_agg_emp
county_ind$output_estabs <- output_agg_estabs

county_ind$supply_emp <- supply_agg_emp
county_ind$supply_estabs <- supply_agg_estabs

```

This provides the final measure for each county-sub-sector entity (i,g), of the average correlation between that entity, and the other sub-sectors within a given geographic distance of the entity of interest. 

This procedure must then be repeated for every county in the dataset. 

## Expanding the Procedure. 

I start by defining an empty dataframe. 

```{r}
final_cbp_results <- county_ind[0,]
```

```{r}
for (i in 1:length(county_list)){
  
  county_name <- c(county_list[i])
  
  county_ind <- cbp_final_io %>% 
    filter(NAME %in% county_name) %>% 
    arrange(ind_code)
  
  #get list of industries in county
  
  ind_in_county <- county_ind %>% 
    filter(!is.na(ind_code)) %>% 
    select(ind_code) %>% 
    distinct() %>%
    unlist() %>% 
    unname()
  
  county_coords <- county_ind %>% 
    ungroup() %>% 
    select(GEO_ID) %>% 
    distinct() %>% 
    left_join(county_centers_cbp) 
  
  county_coords <- county_ind %>% 
    ungroup() %>% 
    select(GEO_ID) %>% 
    distinct() %>% 
    left_join(county_centers_cbp) 
  
  # Create the reference 'sf' object
  ref_point_sf <- county_coords$geometry %>% 
    st_coordinates() %>% as.data.frame() %>% 
    st_as_sf(coords = c("X", "Y"), crs = 4326)
  
  # Compute the distance between the reference point and points from 'df_sf'
  results <- st_distance(df_sf, ref_point_sf) %>% 
    set_units("mi") %>% 
    as.data.frame() %>% 
    drop_units() %>% 
    `colnames<-`(., "dist_mi") 
  
  results$NAME <- cbp_geog$NAME
  results$NAICS2017 <- cbp_geog$NAICS2017
  results$NAICS2017_label <- cbp_geog$NAICS2017_LABEL
  results$industry_code <- cbp_geog$ind_code
  results$ind_a_gi_estabs <- cbp_geog$ind_a_gi_estabs
  results$ind_a_gi_emp <- cbp_geog$ind_a_gi_emp
  results$NAICS_a_gi_estabs <- cbp_geog$NAICS_a_gi_estabs
  results$NAICS_a_gi_emp <- cbp_geog$NAICS_a_gi_emp
  results$ind_estabs <- cbp_geog$county_ind_tot_estabs
  results$ind_emp <- cbp_geog$county_ind_tot_emp
  results$county_estabs <- cbp_geog$county_tot_estabs
  results$county_emp <- cbp_geog$county_tot_emp
  results$county_hhi_emp <- cbp_geog$county_hhi_emp
  results$county_hhi_estabs <- cbp_geog$county_hhi_estabs
  
  results <- results %>%
    arrange(industry_code)
  
  #Get list of industries within a geographic distance
  geog_ind <- results %>% 
    filter(dist_mi < 100) %>% 
    select(industry_code) %>% 
    distinct() %>% 
    unlist() %>% 
    unname()
  
  #Create a J x G matrix of related industries and counties
  results_ind_emp <- county_ind_matrix(ind_a_gi_emp)

  results_ind_estabs <- county_ind_matrix(ind_a_gi_estabs)
  
  #Get County HHI

  cnty_hhi_emp <- results %>% 
    filter(NAME %in% county_name) %>% 
    select(county_hhi_emp) %>% 
    distinct() %>% unlist() %>% unname() 
  
  cnty_hhi_estabs <- results %>% 
    filter(NAME %in% county_name) %>% 
    select(county_hhi_estabs) %>% 
    distinct() %>% unlist() %>% unname() 
  
  #Use list of industries to get index of industries in relatedness measures
  ind_list_index <- which(ind_list %in% geog_ind)
  
  ind_i <- which(geog_ind %in% ind_in_county)
  #There are 3 matrices of interest: X_Ci, Y_Pi, and M_ij. Subsetting these matricies by the index of industries i of interest, against the industries j that are present across geographies, produces a subset of this matrix that describes how each industry i is related to each other industry j in the data. 
  
  input_agg <- X_ij[ind_list_index, ind_list_index] %>% as.matrix()
  
  output_agg <- Y_ij[ind_list_index, ind_list_index]  %>% as.matrix()
  
  supply_agg <- M_ij[ind_list_index, ind_list_index]  %>% as.matrix()
    
  #For each measure, apply a geographic weighting. 
  
  input_emp <- final_matrix_calc(input_agg, results_ind_emp, cnty_hhi_emp)
  input_estab <- final_matrix_calc(input_agg, results_ind_estabs, cnty_hhi_estabs)
  
  output_emp <- final_matrix_calc(output_agg, results_ind_emp, cnty_hhi_emp)
  output_estab <- final_matrix_calc(output_agg, results_ind_estabs, cnty_hhi_estabs)
  
  supply_emp <- final_matrix_calc(supply_agg, results_ind_emp, cnty_hhi_emp)
  supply_estab <- final_matrix_calc(supply_agg, results_ind_estabs, cnty_hhi_estabs)
  
  if (nrow(county_ind) < length(input_emp)) { 
    
    county_ind$input_emp <- input_emp[ind_i]
    county_ind$input_estabs <- input_estab[ind_i]
      
    county_ind$output_emp <- output_emp[ind_i]
    county_ind$output_estabs <- output_estab[ind_i]
    
    county_ind$supply_emp <- supply_emp[ind_i]
    county_ind$supply_estabs <- supply_estab[ind_i]
    
  }
  
  else {
    county_ind$input_emp <- input_emp
    county_ind$input_estabs <- input_estab
      
    county_ind$output_emp <- output_emp
    county_ind$output_estabs <- output_estab
    
    county_ind$supply_emp <- supply_emp
    county_ind$supply_estabs <- supply_estab
  }
  
  final_cbp_results <- bind_rows(final_cbp_results, county_ind)

}
```


```{r}
final_cbp_results %>% 
  saveRDS(here("Final Data/final_cbp_io_results.RDS"))
```

```{r, eval = FALSE}
#THIS VERSION IS THE ADJUSTED VERSION WITH ESTABLISHMENT WEIGHTING
final_cbp_results %>% 
  saveRDS(here("Final Data/final_cbp_io_results_hhi.RDS"))
```



# Results 

```{r}
final_cbp_results <- readRDS(here("Final Data/final_cbp_io_results.RDS"))
```


```{r}
state_quads <- readRDS(here("State Data/state_quadrants_1.RDS"))
```


```{r}
final_results_merge <- final_cbp_results %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) 
```


```{r}
final_results_merge %>% 
  select(input_emp, output_emp, supply_emp, input_estabs, output_estabs, supply_estabs, everything()) %>% 
  view()
```

```{r}
filter_function <- function(data, var){
  
  data %>% 
    filter({{ var }} > 0) %>% 
    mutate(mean_var = mean(log({{ var} }), na.rm = TRUE)) %>% 
    select(mean_var) %>% 
    distinct() %>% 
    unlist() %>% 
    unname()
  
}
```

```{r}
agg_means <- data.frame(input_emp = filter_function(final_results_merge, input_emp), 
                        input_estabs = filter_function(final_results_merge, input_estabs), 
                        output_emp = filter_function(final_results_merge, output_emp), 
                        output_estabs = filter_function(final_results_merge, output_estabs), 
                        supply_emp = filter_function(final_results_merge, supply_emp), 
                        supply_estabs = filter_function(final_results_merge, supply_estabs))
```



### Employment and Establishments


```{r}
emp_emp <- final_results_merge %>% 
  filter(output_emp > 0, supply_emp != 0) %>% 
  ggplot() + 
  geom_point(shape = 21, aes(x = log(output_emp), y = log(supply_emp), fill = naics_3digit_label)) + 
  geom_hline(yintercept = agg_means$supply_emp) + 
  geom_vline(xintercept = agg_means$output_emp) + 
  scale_fill_manual(values = emp_ind_vector) + 
  guides(fill = "none") +
  facet_wrap(~naics_3digit_label) + 
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEmployment", y = "County-Subsector Index of Supply Vertical Agglomeration \nEmployment") +
  theme_bw() + 
  axis_theme

emp_emp
```

```{r}
emp_estabs <- final_results_merge %>% 
  filter(output_emp > 0, supply_estabs != 0) %>% 
  ggplot() + 
  geom_point(shape = 21, aes(x = log(output_emp), y = log(supply_estabs), fill = naics_3digit_label)) + 
  geom_hline(yintercept = agg_means$supply_estabs) + 
  geom_vline(xintercept = agg_means$output_emp) + 
  scale_fill_manual(values = emp_ind_vector) + 
  guides(fill = "none") +
  facet_wrap(~naics_3digit_label) + 
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEmployment", y = "County-Subsector Index of Supply Vertical Agglomeration \nEstablishments") +
  theme_bw() + 
  axis_theme

emp_estabs
```

```{r}
estabs_estabs <- final_results_merge %>% 
  filter(output_estabs > 0, supply_estabs != 0) %>% 
  ggplot() + 
  geom_point(shape = 21, aes(x = log(output_estabs), y = log(supply_estabs), fill = naics_3digit_label)) + 
  geom_hline(yintercept = agg_means$supply_estabs) + 
  geom_vline(xintercept = agg_means$output_estabs) + 
  scale_fill_manual(values = emp_ind_vector) + 
  guides(fill = "none") +
  facet_wrap(~naics_3digit_label) + 
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Supply Vertical Agglomeration \nEstablishments") +
  theme_bw() + 
  axis_theme

estabs_estabs
```


```{r}
input_output_comp <- final_results_merge %>% 
  ggplot() + 
  geom_point(shape = 21, aes(x = log(output_estabs), y = log(input_estabs), fill = naics_3digit_label), alpha = 0.7) + 
  scale_fill_manual(values = emp_ind_vector) + 
  guides(fill = "none") +
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Input Horizontal Agglomeration \nEstablishments") +
  theme_bw() + 
  axis_theme

input_output_comp
```


```{r}
output_supply_comp <- final_results_merge %>% 
  filter(output_estabs > 0, supply_estabs != 0) %>% 
  ggplot() + 
  geom_point(shape = 21, aes(x = log(output_estabs), y = log(supply_estabs), fill = naics_3digit_label)) + 
  geom_vline(xintercept = agg_means$output_estabs) + 
  geom_hline(yintercept = agg_means$supply_estabs) + 
  scale_fill_manual(values = emp_ind_vector) + 
  guides(fill = "none") +
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Supply Vertical Agglomeration \nEstablishments") +
  theme_bw() + 
  axis_theme

output_supply_comp
```

```{r}
input_supply_comp <- final_results_merge %>% 
  ggplot() + 
  geom_point(shape = 21, aes(x = log(input_estabs), y = log(supply_estabs), fill = naics_3digit_label), alpha = 0.7) + 
  scale_fill_manual(values = emp_ind_vector) + 
  guides(fill = "none") +
  labs(x = "County-Subsector Index of Input Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Supply Vertical Agglomeration \nEstablishments") +
  theme_bw() + 
  axis_theme

input_supply_comp
```

```{r}
sector_comp <- final_results_merge %>% 
  filter(naics_3digit %in% c(334, 336))

sector_col <- get_col_match(sector_comp)

sector_comp1 <- sector_comp %>% 
  ggplot() + 
  geom_point(shape = 21, aes(x = log(output_estabs), y = log(supply_estabs), fill = naics_3digit_label)) + 
  geom_vline(xintercept = -10) + 
  geom_hline(yintercept = -16) + 
  scale_fill_manual(values = sector_col) + 
  facet_wrap(~naics_3digit_label) + 
  guides(fill = "none") +
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Supply Vertical Agglomeration \nEstablishments") +
  theme_bw() + 
  axis_theme

sector_comp1
```

```{r}
sector_comp <- final_results_merge %>% 
  filter(naics_3digit %in% c(336)) %>% 
  group_by(industry_desc) %>% 
  mutate(count = n()) %>% 
  filter(count > 3)

sector_col <- get_col_match(sector_comp)

sector_comp2 <- sector_comp %>% 
  filter(output_estabs > 0, supply_estabs != 0) %>% 
  ggplot() + 
  geom_point(shape = 21, aes(x = log(output_estabs), y = log(supply_estabs), fill = naics_3digit_label)) + 
  geom_vline(xintercept = agg_means$output_estabs) + 
  geom_hline(yintercept = agg_means$supply_estabs) + 
  scale_fill_manual(values = sector_col) + 
  facet_wrap(~industry_desc) + 
  guides(fill = "none") +
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Supply Vertical Agglomeration \nEstablishments") +
  theme_bw() + 
  axis_theme

sector_comp2
```


```{r}
sector_comp_gran <- final_results_merge %>% 
  filter(industry_code %in% c("334413", "336411", "336111"))

sector_gran_col <- get_col_match(sector_comp_gran)
```

```{r}
gran_graph_estabs_estabs <- sector_comp_gran %>%
  filter(output_estabs > 0, supply_estabs != 0) %>% 
  mutate(county_label = case_when(state_abbr == "CA" ~ NAME)) %>% 
  ggplot(aes(text = NAME)) + 
  geom_point(shape = 21, aes(x = log(output_estabs), y = log(supply_estabs), fill = naics_3digit_label), size = 3) + 
  # geom_label_repel(aes(x = log(output_estabs), y = log(supply_estabs), fill = naics_3digit_label, label = county_label)) + 
  scale_fill_manual(values = sector_gran_col) + 
  geom_vline(xintercept = agg_means$output_estabs) + 
  geom_hline(yintercept = agg_means$supply_estabs) + 
  facet_wrap(~industry_desc) + 
  guides(fill = "none") +
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Supply Vertical Agglomeration \nEstablishments") +
  theme_bw() + 
  axis_theme
```

```{r}
semicondcutor_comp <- final_results_merge %>% 
  filter(industry_code %in% c("334413"))

semicondcutor_comp_col <- get_col_match(semicondcutor_comp)
```

```{r}
semiconductor_estabs_estabs <- semicondcutor_comp %>%
  filter(output_estabs > 0, supply_estabs != 0) %>% 
  mutate(county_label = case_when(str_detect(NAME, "Washington County|Dallas|Maricopa") ~ NAME)) %>% 
  ggplot(aes(text = NAME)) + 
  geom_point(shape = 21, aes(x = log(output_estabs), y = log(supply_estabs), fill = naics_3digit_label, size = ind_emp_lq*10)) + 
  scale_fill_manual(values = semicondcutor_comp_col) + 
  geom_vline(xintercept = agg_means$output_estabs) + 
  geom_hline(yintercept = agg_means$supply_estabs) + 
  xlim(-15, -7.5) + 
  ylim(-25, -10) + 
  facet_wrap(~industry_desc) + 
  guides(fill = "none", size = "none") +
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Supply Vertical Agglomeration \nEstablishments") +
  theme_bw() + 
  axis_theme
```
```{r}
gran_graph_estabs_emp <- sector_comp_gran %>%
  filter(output_estabs > 0, supply_emp != 0) %>% 
  ggplot() + 
  geom_point(shape = 21, aes(x = log(output_estabs), y = log(supply_emp), fill = naics_3digit_label)) + 
  scale_fill_manual(values = sector_gran_col) + 
  geom_vline(xintercept = agg_means$output_estabs) + 
  geom_hline(yintercept = agg_means$supply_emp) + 
  facet_wrap(~industry_desc) + 
  guides(fill = "none") +
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Supply Vertical Agglomeration \nEmployment") +
  theme_bw() + 
  axis_theme
```


```{r}
geom_label_repel(aes(x = log(output_estabs), y = log(supply_estabs), fill = naics_3digit_label, label = NAME)) + 
```

```{r}
sector_comp_gran %>%
  filter(output_estabs > 0, supply_estabs != 0, NAME %in% c(la_list)) %>% 
  ggplot() + 
  geom_point(shape = 21, aes(x = log(output_estabs), y = log(supply_estabs), fill = naics_3digit_label), size = 3) + 
  geom_label_repel(aes(x = log(output_estabs), y = log(supply_estabs), fill = naics_3digit_label, label = NAME)) + 
  scale_fill_manual(values = sector_gran_col) + 
  geom_vline(xintercept = agg_means$output_estabs) + 
  geom_hline(yintercept = agg_means$supply_estabs) + 
  guides(fill = "none") +
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Supply Vertical Agglomeration \nEstablishments") +
  theme_bw() + 
  axis_theme
```


```{r}
gran_graph_emp_estabs <- sector_comp_gran %>%
  filter(output_emp > 0, supply_estabs != 0) %>% 
  ggplot() + 
  geom_point(shape = 21, aes(x = log(output_emp), y = log(supply_estabs), fill = naics_3digit_label)) + 
  scale_fill_manual(values = sector_gran_col) + 
  geom_vline(xintercept = agg_means$output_emp) + 
  geom_hline(yintercept = agg_means$supply_estabs) + 
  facet_wrap(~industry_desc) + 
  guides(fill = "none") +
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEmployment", y = "County-Subsector Index of Supply Vertical Agglomeration \nEstablishments") +
  theme_bw() + 
  axis_theme
```

```{r}
gran_graph_emp_emp <- sector_comp_gran %>%
  filter(output_emp > 0, supply_emp != 0) %>% 
  ggplot() + 
  geom_point(shape = 21, aes(x = log(output_emp), y = log(supply_emp), fill = naics_3digit_label)) + 
  scale_fill_manual(values = sector_gran_col) + 
  geom_vline(xintercept = agg_means$output_emp) + 
  geom_hline(yintercept = agg_means$supply_emp) + 
  facet_wrap(~industry_desc) + 
  guides(fill = "none") +
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEmployment", y = "County-Subsector Index of Supply Vertical Agglomeration \nEmployment") +
  theme_bw() + 
  axis_theme
```



```{r}
ind_dist <- final_results_merge %>% 
  filter(output_estabs != 0, supply_estabs != 0) %>%
  ggplot() + 
  geom_point(shape = 21, aes(x = log(output_estabs), y = log(supply_estabs), fill = naics_3digit_label)) + 
  geom_hline(yintercept = -15.6) + 
  geom_vline(xintercept = -11.9) +  
  scale_fill_manual(values = emp_ind_vector) + 
  guides(fill = "none") + 
  facet_wrap(~naics_3digit_label) + 
  labs(x = "County-Subsector Index of Input Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Supply Vertical Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme 

ind_dist
 
```


```{r}
state_dist <- final_results_merge %>% 
  filter(output_estabs != 0, supply_estabs != 0) %>%
  ggplot() + 
  geom_point(shape = 21, aes(x = log(output_estabs), y = log(supply_estabs), fill = naics_3digit_label)) + 
   geom_hline(yintercept = -15.6) + 
  geom_vline(xintercept = -11.9) + 
  scale_fill_manual(values = emp_ind_vector) + 
  guides(fill = "none") + 
  facet_geo(~state_abbr) + 
  labs(x = "County-Subsector Index of Input Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Supply Vertical Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme 
```


```{r}
final_results_merge %>% 
  filter(input_emp )
  ggplot(aes(x  = input_emp, y = naics_3digit_label, fill = naics_3digit_label, group = naics_3digit_label)) + 
  geom_density_ridges(aes(), alpha = 0.7, jittered_points = TRUE, point_alpha=1,point_shape=21) + 
  scale_fill_manual(values = emp_ind_vector) + 
  guides(fill = "none") 
```

```{r}
case_study <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  filter(NAME %in% c("Snohomish County, Washington", "Los Angeles County, California", "Wayne County, Michigan", "Alameda County, California")) 
```

```{r}
case_study_cols <- get_col_match(case_study)
```

```{r}
case_study_counties <- c("Snohomish County, Washington", "Wayne County, Michigan", "Alameda County, California", "Los Angeles County, California")
```


```{r}
overall_estabs_horz <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(str_detect(NAME, "Honolulu County, Hawaii", negate = TRUE)) %>% 
  mutate(point_label = case_when(
    vert1_estab_mean >= 25 | horz_estab_mean > 21 ~ paste(industry_desc, NAME, sep = "\n"))) %>% 
ggplot(aes(x = vert1_estab_mean, y = horz_estab_mean, fill = naics_3digit_label, text = paste(industry_desc, NAME, sep = "\n")))  + 
  geom_point(shape = 21, aes(size = ind_gi_state_share_estab*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  labs(x = "County-Subsector Index of Input Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Output Horizontal Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))

overall_estabs_horz
```
```{r}
overall_estabs_horz + geom_label_repel(aes(label = point_label), size = 3, max.overlaps = 60)
```


```{r}
overall_emp_horz <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(str_detect(NAME, "Honolulu County, Hawaii", negate = TRUE), 
         vert1_emp_mean <100) %>% 
  mutate(point_label = case_when(
    vert1_estab_mean >= 25 | horz_estab_mean > 21 ~ paste(industry_desc, NAME, sep = "\n"))) %>% 
ggplot(aes(x = vert1_emp_mean, y = horz_emp_mean, fill = naics_3digit_label, text = paste(industry_desc, NAME, sep = "\n")))  + 
  geom_point(shape = 21, aes(size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  labs(x = "County-Subsector Index of Input Horizontal Agglomeration \nEmployment", y = "County-Subsector Index of Output Horizontal Agglomeration \nEmployment") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))

overall_emp_horz
```


```{r}
overal_vert_emp <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(str_detect(NAME, "Honolulu County, Hawaii", negate = TRUE), 
         vert1_emp_mean <100) %>% 
  #mutate(point_label = case_when(
    #vert1_estab_mean >= 25 | horz_estab_mean > 21 ~ paste(industry_desc, NAME, sep = "\n"))) %>% 
ggplot(aes(x = vert1_emp_mean, y = vert2_emp_mean, fill = naics_3digit_label, text = paste(industry_desc, NAME, sep = "\n")))  + 
  geom_point(shape = 21, aes(size = ind_gi_state_share_estab*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  labs(x = "County-Subsector Index of Input Horizontal Agglomeration \nEmployment", y = "County-Subsector Index of Vertical Agglomeration \nEmployment") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))
```


```{r}
overall_vert_estabs <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(str_detect(NAME, "Honolulu County, Hawaii", negate = TRUE), 
         vert1_emp_mean <100) %>% 
  #mutate(point_label = case_when(
    #vert1_estab_mean >= 25 | horz_estab_mean > 21 ~ paste(industry_desc, NAME, sep = "\n"))) %>% 
ggplot(aes(x = vert1_estab_mean, y = vert2_estab_mean, fill = naics_3digit_label, text = paste(industry_desc, NAME, sep = "\n")))  + 
  geom_point(shape = 21, aes(size = ind_gi_state_share_estab*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  labs(x = "County-Subsector Index of Input Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Vertical Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))
```


```{r}
horz_vert_estabs <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(str_detect(NAME, "Honolulu County, Hawaii", negate = TRUE), 
         vert1_emp_mean <100) %>% 
  #mutate(point_label = case_when(
    #vert1_estab_mean >= 25 | horz_estab_mean > 21 ~ paste(industry_desc, NAME, sep = "\n"))) %>% 
ggplot(aes(x = horz_estab_mean, y = vert2_estab_mean, fill = naics_3digit_label, text = paste(industry_desc, NAME, sep = "\n")))  + 
  geom_point(shape = 21, aes(size = ind_gi_state_share_estab*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Vertical Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))
```


```{r}
horz_vert_emp <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(str_detect(NAME, "Honolulu County, Hawaii", negate = TRUE), 
         vert1_emp_mean <100) %>% 
  #mutate(point_label = case_when(
    #vert1_estab_mean >= 25 | horz_estab_mean > 21 ~ paste(industry_desc, NAME, sep = "\n"))) %>% 
ggplot(aes(x = horz_emp_mean, y = vert2_emp_mean, fill = naics_3digit_label, text = paste(industry_desc, NAME, sep = "\n")))  + 
  geom_point(shape = 21, aes(size = ind_gi_state_share_estab*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Vertical Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))
```

### Case Study Results


```{r}
case_study_1_emp <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(NAME %in% case_study_counties) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = log(ind_a_gi_emp*vert1_emp_mean), y = horz_emp_mean, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  facet_wrap(~NAME) + 
  labs(x = "Log Weighted County-Subsector Index of Input Horizontal Agglomeration \nEmployment", y = "County-Subsector Index of Output Horizontal Agglomeration \nEmployment") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))

case_study_1_emp
```


```{r}
case_study_1_estabs <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(NAME %in% case_study_counties) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = log(ind_a_gi_estabs*vert1_estab_mean), y = horz_estab_mean, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  facet_wrap(~NAME) + 
  labs(x = "Log Weighted County-Subsector Index of Input Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Output Horizontal Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))

case_study_1_estabs
```

NOTE: The following are consistent around either definition of horizontal agglomeration

```{r}
cs_2_emp <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(NAME %in% case_study_counties) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = log(ind_a_gi_emp*vert_1_emp_mean), y = vert2_emp_mean, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  facet_wrap(~NAME) + 
  labs(x = "Log Weighted County-Subsector Index of Horizontal Agglomeration \nEmployment", y = "County-Subsector Index of Vertical Agglomeration \nEmployment") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))
```


```{r}
cs_2_estabs <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(NAME %in% case_study_counties) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = log(ind_a_gi_estabs*vert1_estab_mean), y = vert2_estab_mean, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  facet_wrap(~NAME) + 
  labs(x = "Log Weighted County-Subsector Index of Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Vertical Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))
```



```{r}
case_study_3 <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(NAME %in% case_study_counties) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = log(ind_a_gi_emp*horz_emp_mean), y = log(ind_a_gi_estabs*vert2_estab_mean), fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  facet_wrap(~NAME) + 
  labs(x = "Weighted Log County-Subsector Index of Horizontal Agglomeration \nEmployment", y = "Weighted-Log County-Subsector Index of Vertical Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))

case_study_3
```

### Without Los Angeles

Because Los Angeles is such an outlier, and dominates in terms of both horizontal and vertical agglomeraiton, consider each of the above graphs without Los Angeles.

```{r}
case_study_wola <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  filter(NAME %in% c("Snohomish County, Washington", "Wayne County, Michigan", "Alameda County, California")) 
```

```{r}
case_study_wola_cols <- get_col_match(case_study_wola)
```

```{r}
case_study_wola_counties <- c("Snohomish County, Washington", "Wayne County, Michigan", "Alameda County, California")
```

```{r}
wola_1_emp <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(NAME %in% case_study_wola_counties) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = log(ind_a_gi_emp*vert1_emp_mean), y = horz_emp_mean, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_wola_cols) + 
  guides(fill = "none", size = "none") + 
  facet_wrap(~NAME) + 
  labs(x = "Log Weighted County-Subsector Index of Input Horizontal Agglomeration \nEmployment", y = "County-Subsector Index of Output Horizontal Agglomeration \nEmployment") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))

wola_1_emp
```

```{r}
wola_1_estabs <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(NAME %in% case_study_wola_counties) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = log(ind_a_gi_estabs*vert1_estab_mean), y = horz_estab_mean, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_wola_cols) + 
  guides(fill = "none", size = "none") + 
  facet_wrap(~NAME) + 
  labs(x = "Log Weighted County-Subsector Index of Input Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Output Horizontal Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))

wola_1_estabs
```



```{r}
wola_2_emp <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(NAME %in% case_study_wola_counties) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = log(ind_a_gi_emp*vert1_emp_mean), y = vert2_emp_mean, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_wola_cols) + 
  guides(fill = "none", size = "none") + 
  facet_wrap(~NAME) + 
  labs(x = "Log Weighted County-Subsector Index of Horizontal Agglomeration \nEmployment", y = "County-Subsector Index of Vertical Agglomeration \nEmployment") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))
```


```{r}
wola_2_estabs <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(NAME %in% case_study_wola_counties) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = log(ind_a_gi_estabs*vert1_estab_mean), y = vert2_estab_mean, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_wola_cols) + 
  guides(fill = "none", size = "none") + 
  facet_wrap(~NAME) + 
  labs(x = "Log Weighted County-Subsector Index of Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Vertical Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))
```

```{r}
wola_3 <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./max(.))) %>%   
  filter(NAME %in% case_study_wola_counties) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = log(ind_a_gi_emp*horz_emp_mean), y = log(ind_a_gi_estabs*vert2_estab_mean), fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_wola_cols) + 
  guides(fill = "none", size = "none") + 
  facet_wrap(~NAME) + 
  labs(x = "Weighted Log County-Subsector Index of Horizontal Agglomeration \nEmployment", y = "Weighted-Log County-Subsector Index of Vertical Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))

wola_3
```

```{r}
wola_3_unweighted <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
  filter(NAME %in% case_study_wola_counties) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = log(ind_a_gi_emp*horz_emp_mean), y = vert2_estab_mean, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_wola_cols) + 
  guides(fill = "none", size = "none") + 
  facet_wrap(~NAME) + 
  labs(x = "Weighted Log County-Subsector Index of Horizontal Agglomeration \nEmployment", y = "County-Subsector Index of Vertical Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))

wola_3_unweighted
```

### Final Results

```{r}
full_graph_unweighted <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%   
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = log(ind_a_gi_emp*horz_emp_mean), y = vert2_estab_mean, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  labs(x = "Weighted Log County-Subsector Index of Output Horizontal Agglomeration \nEmployment", y = "County-Subsector Index of Vertical Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))
```


```{r}
full_graph_weighted <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
   mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%  
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = log(ind_a_gi_emp*horz_emp_mean), y = log(ind_a_gi_estabs*vert2_estab_mean), fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  # geom_vline(xintercept = -12) + 
  # geom_hline(yintercept = -12) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  labs(x = "Weighted Log County-Subsector Index of Horizontal Agglomeration \nEmployment", y = "Weighted Log County-Subsector Index of Vertical Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))
```

```{r}
means <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(industry_desc) %>% 
  # mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%
  mutate(horz_measure = log(ind_a_gi_emp*horz_emp_mean),
         vert_measure = log(ind_a_gi_estabs*vert2_estab_mean),
         horz_index = horz_measure / mean(horz_measure),
         vert_index = vert_measure / mean(vert_measure), 
        mean_horz = mean(horz_index), 
         mean_vert = mean(vert_index), ) %>% 
  filter(naics_3digit_label %in% c("Transportation equipment manufacturing")) %>% 
  select(mean_horz, mean_vert) %>% 
  distinct()
```


```{r}
#index  version? Doesn't seem right!! Index over average of naics_3digit or industry level? 
mask_states_weighted_index <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(industry_desc) %>% 
  # mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%
  mutate(horz_measure = log(ind_a_gi_emp*horz_emp_mean),
         vert_measure = log(ind_a_gi_estabs*vert2_estab_mean),
         mean_horz = mean(horz_measure), 
         mean_vert = mean(vert_measure),
         horz_index = horz_measure / mean(horz_measure),
         vert_index = vert_measure / mean(vert_measure)) %>%
  filter(state_abbr %in% c("MA", "AL", "IN", "NY", "MI", "WA")) %>% 
  filter(naics_3digit_label %in% c("Transportation equipment manufacturing")) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = horz_index, y = vert_index, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  geom_vline(xintercept = means$mean_horz) + 
  geom_hline(yintercept = means$mean_vert) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  labs(x = "Weighted Log County-Subsector Index of Horizontal Agglomeration \nEmployment", y = "Weighted Log County-Subsector Index of Vertical Agglomeration \nEstablishments") + 
  facet_wrap(~state_abbr) + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))
  
```


```{r}
#index  version? 
mask_states_weighted <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  # mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>%
  mutate(horz_measure = log(ind_a_gi_emp*horz_emp_mean),
         vert_measure = log(ind_a_gi_estabs*vert2_estab_mean),
         horz_index = horz_measure / mean(horz_measure),
         vert_index = vert_measure / mean(vert_measure)) %>%
  filter(state_abbr %in% c("MA", "AL", "IN", "NY", "MI", "WA")) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = horz_index, y = vert_index, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 

  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  labs(x = "Weighted Log County-Subsector Index of Horizontal Agglomeration \nEmployment", y = "Weighted Log County-Subsector Index of Vertical Agglomeration \nEstablishments") + 
  facet_wrap(~state_abbr) + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))
  
```



```{r}
mask_states_unweighted <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./mean(.))) %>% 
  filter(state_abbr %in% c("MA", "AL", "IN", "NY", "MI", "WA")) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = log(ind_a_gi_emp*horz_emp_mean), y = vert2_estab_mean, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  labs(x = "Weighted Log County-Subsector Index of Horizontal Agglomeration \nEmployment", y = "County-Subsector Index of Vertical Agglomeration \nEstablishments") + 
  facet_wrap(~state_abbr) + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))
```

### Backups

```{r}
case_study_emp <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./max(.))) %>%   
  filter(NAME %in% case_study_counties) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = horz_emp_mean, y = vert2_emp_mean, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  facet_wrap(~NAME) + 
  labs(x = "County-Subsector Index of Output Horizontal Agglomeration \nEmployment", y = "County-Subsector Index of Vertical Agglomeration \nEmployment") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))

case_study_emp
```


```{r}
case_study_emp1 <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./max(.))) %>%   
  filter(NAME %in% case_study_counties) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = vert1_emp_mean, y = vert2_emp_mean, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  facet_wrap(~NAME) + 
  labs(x = "County-Subsector Index of Input Horizontal Agglomeration \nEmployment", y = "County-Subsector Index of Vertical Agglomeration \nEmployment") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))

case_study_emp1
```




```{r}
case_study_estabs <- final_results_merge %>% 
  filter(!is.na(state_abbr)) %>% 
  left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
  left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
  group_by(naics_3digit_label) %>% 
  mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./max(.))) %>%   
  filter(NAME %in% case_study_counties) %>% 
ggplot(aes(text = paste(industry_desc, NAME, sep = "\n"))) + 
  geom_point(shape = 21, aes(x = vert1_estab_mean, y = vert2_estab_mean, fill = naics_3digit_label, size = ind_gi_state_share_emp*100)) + 
  scale_fill_manual(values = case_study_cols) + 
  guides(fill = "none", size = "none") + 
  facet_wrap(~NAME) + 
  labs(x = "County-Subsector Index of Input Horizontal Agglomeration \nEstablishments", y = "County-Subsector Index of Vertical Agglomeration \nEstablishments") + 
  theme_bw() + 
  axis_theme + 
  theme(strip.text.x = element_text(size = 14))

case_study_estabs
```







```{r}
final_results_merge %>% 
    filter(!is.na(state_abbr)) %>% 
    left_join(ind_crosswalk %>% rename(ind_code = industry_code)) %>% 
    left_join(state_quads %>% select(state_abbr, state_quadrant)) %>% 
    group_by(naics_3digit_label) %>% 
    mutate(across(.cols = c(horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ~ ./max(.))) %>%
  mutate(log_horz = log(horz_emp_mean), 
         log_vert2 = log(vert2_emp_mean)) %>% select(c(log_horz, log_vert2, horz_emp_mean, horz_estab_mean, vert1_emp_mean, vert1_estab_mean, vert2_emp_mean, vert2_estab_mean), ind_code, industry_desc, NAME, everything()) %>%
  
    view()
```

Instead, I define geographic and relational restriction to measure the 


For a given commodity $c$ and a given manufacturing sub-sector $i$ let $\epsilon_i$ be $i$'s total share of commodity output (percentage of total dollar value of output): 

## Mapping Input Trends at the State Level

(Can't do this yet, need data across time. Might be useful?)


# Old Work

I normalize this measure with $\lambda_c$, the share of the value of the total output of commodity c that is used as an intermediate input.

$$\phi_{j,c} = \sum_{P_c \in C_i} Y_{j,p} * = \sum_{P_c \in C_i} \frac{p_j}{p_{tot}}$$

For all commodities $P_c$ in $C_i$, the set of commodities that industry $i$ uses as intermediate inputs, 

$\lambda_c * x_{i,c} * 

I then define $p_{i,c}$ as the share of the value of the output of commodity c that industry $i$ supplies. I can then construct a matrix $M_{P_i}$ with columns representing industries and rows representing the share of the value of the commodities that these i 

As such, I first define $C_{x_i}$ as a matrix with columns representing 

To link production and use 

numerator: use of commodity y as an input
denominator: Total use of inputs by X

 mutate(input_share = value_num / intermediary_inputs) 


Consider two industries, $i$ and $j$, two measures capture the intensity of relatedness between two industries (adaption of Fraser and Bergman, 2000): 

$x_{ij}, x_{ji}$: intermediate commodities used by industry (i) from i (j) as a proportion of j's (i's) total intermediate goods purchases. A large value suggests that industry j depends on industry i as a source for a large proportion for its total intermediate inputs. 

$y_{ij}, y{ji}$: intermediate goods sales from i (j) to j (i) as a proportion of i's (j's) total intermediate goods sales. A larger value suggests that i depends on industry j as a market for a large proportion of its total intermediate goods sales. 

With these measures, it is possible to create a variety of matrices relating industries together. I focus first on defining industries by the degree to which they have common input purchasing patterns, in contrast to the standard NAICS classification system, which groups industries together based on the production of common outputs. 

This measure is $r(x_i, x_j)$: the degree to which industries $i$ and $j$ have similar input purchasing patterns. In addition to this measure, I adopt two other measures proposed by Fraser and Bergman, 2000: 

$r(y_i, y_j)$: the degree to which industries $i$ and $j$ have possess similar output selling patterns. Here, I note that this will generally be best classified by the existing NAICS system. 

$r(x_i, y_j)$: the degree to which the buying pattern of industry $i$ matches the output pattern of industry $j$ (and reverse, as well)

Whereas existing work using Input-Output accounts either reduces these variables to a single, maximum value (Delgado et al., 2014), or combines them together in a principle component analysis (Fraser and Bergman, 2000), I use each of these measures separately, and argue that they each capture unique aspects of sectoral variation in inputs and outputs. 

Focusing on the manufacturing sector, the input-output use table results in a 232x326 matrix of 232 manufacturing industries (i), and their use of 326 commodities (c).  

1. Total commodity output: in the SUPPLY table, output by commodity
2. Total Product supply, basic price, total product supply purchasers prices (in the SUPPLY table), by commodity


3. Total industry output (in the USE table)
4. Total intermediate inputs ($ value of intermediate inputs used) USE Table
- USE Table gives us total use of each commodity by each industry, as well as total production





5. Total value of use of products, in the USE table, matches with product supply purchasers prices
6. Total value of use of products as intermediate inputs, in the USE table

5. Total exports of commodities (in the USE Table)
6. Total imports of commodities (in the SUPPLY Table)

7. Total industry supply as intermediate input, in the USE Table
8. Total industry supply as all value

Other measures: value of nongov IP investment, valeu of GOV ip investment, exports, value of state and local IP investment (all in the USE table)

the input-output supply table data results in a 232x255 matrix of 232 manufacturing industries (i), and their output of 255 commodities (c).