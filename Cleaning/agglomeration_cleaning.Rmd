---
title: "Varieties of Agglomeration"
author: "Nikhil Kalathil"
date: "2023-12-04"
output: html_document
---

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warnings = FALSE)
```

```{r, include = FALSE}
#Libraries
library(tigris)
library(tidyverse)
library(here)
library(leaflet)
library(ggrepel)
library(RColorBrewer)
library(grid)
library(gridExtra)
library(cowplot)
library(readxl)
library(janitor)
library(geofacet)
library(jsonlite)
library(ggridges)
library(sf)
library(here)
library(patchwork)
library(plotly)
library(leaflet.extras)
library(units)

set.seed(37)
title_theme <- theme(axis.text = element_text(size = 14), 
        axis.title = element_text(size = 18), 
        title = element_text(size = 20))

axis_theme <- theme(axis.text = element_text(size = 10), 
        axis.title = element_text(size = 18), 
         strip.text.x = element_text(size = 14))
```

```{r, include = FALSE}
#Area Crosswalks
area_codes <- readRDS(here("State Data/area_crosswalk.RDS")) %>% 
  mutate(area_title = str_remove(area_title, " -- Statewide")) %>% 
  mutate(area_fips = case_when(
    nchar(area_fips) == 4 ~ paste("0", area_fips, sep = ""), 
    TRUE ~ area_fips
  ))

states <- data.frame(state_abbr = state.abb, area_title = state.name)

area_codes <- left_join(area_codes, states) %>% 
  mutate(state_abbr = case_when(
    area_title == "District of Columbia" ~ "DC",
    area_title == "Puerto Rico" ~ "PR",
    TRUE ~ state_abbr))
```


```{r}
ExpandColorsLIGHT <- function(colors, n, steps = 11){
  if(n <= steps){
    suppressWarnings({
      sapply(colors, function(x){colorRampPalette(c(x, "#FFFFFF"))(steps)}) %>% 
        as.data.frame() %>% 
        filter(row_number() <= n) %>% 
        gather(key = original.color, value = expanded.color)
    })
  }else{
    warning("Select n < steps!")
  }
}
```


```{r}
ExpandColorsDARK <- function(colors, n, steps = 11){
  if(n <= steps){
    suppressWarnings({
      sapply(colors, function(x){colorRampPalette(c(x, "#000000"))(steps)}) %>% 
        as.data.frame() %>% 
        filter(row_number() <= n) %>% 
        gather(key = original.color, value = expanded.color)
    })
  }else{
    warning("Select n < steps!")
  }
}
```

```{r, include = FALSE}
#Map Data
county_sf <- counties(cb = TRUE) %>% 
  shift_geometry(position = "outside")
states_sf <- states(cb = TRUE, resolution = "20m") %>%
  shift_geometry(position = "outside")
```



```{r, include = FALSE}
#Change projection of data for leaflet

states_leaflet <- states_sf %>% 
  sf::st_transform('+proj=longlat +datum=WGS84')

counties_leaflet <- county_sf %>% 
  sf::st_transform('+proj=longlat +datum=WGS84') 
```

```{r, include = FALSE}
#Convert county data to a table
county_data <- counties_leaflet %>% 
  as_tibble() %>% 
  select(STATEFP, COUNTYFP, AFFGEOID) %>% 
  mutate(area_fips = paste(STATEFP, COUNTYFP, sep = ""), 
         st = as.numeric(STATEFP))
```


```{r, include = FALSE}
#Get center of each county
county_centers <- counties_leaflet %>% 
  filter(str_detect(NAME, "Mariana", negate = TRUE)) %>% 
  st_centroid() %>% 
  sf::st_transform('+proj=longlat +datum=WGS84')
```

```{r, include = FALSE}
#Load Existing Data
qcew_3digits <- readRDS(here("State Data/qcew_3digit.RDS")) %>% 
  mutate(industry_desc = substring(industry_title, 11))
```

```{r, include = FALSE}
#Simplify to get industry codes
ind_3digit <- qcew_3digits %>% 
  select(naics_3digit = ind_code, naics_3digit_label = industry_desc) %>% 
  distinct() %>% 
  arrange(naics_3digit_label)
```

```{r, include = FALSE}
#Define colors 
emp_ind_vector <- c(brewer.pal(9, "Greys")[4], "#cf4633", "#BEAED4", "#a8e4a0", "#FDBF6F",  "#386CB0", "#FB8072", brewer.pal(9, "Greys")[3], brewer.pal(9, "Greys")[8], "#80B1D3", "#F0027F",  "#4DAF4A", "#F1E2CC", "#6A3D9A", "#E78AC3", "#CBD5E8", "#666666", brewer.pal(9, "Greys")[5],  brewer.pal(9, "Greys")[6], "#A65628", brewer.pal(9, "Greys")[7])
```

```{r}
#create data frame mapping colors to industries
col_map <- data.frame(ind_3digit$naics_3digit_label, emp_ind_vector)
```

```{r}
rd_col <- data.frame(ind_3digit.naics_3digit_label = "Scientific R&D", emp_ind_vector = "#8DD3C7")
```

```{r}
col_map <- bind_rows(col_map, rd_col)
```


```{r}
# Map 3-digit NAICS to 3-digit Colors
get_col_vec <- function(data){ 
  data %>% 
    select(naics_3digit_label) %>% 
    distinct() %>% 
    unlist()
  }
```

```{r}
#Function to get appropriate 3-digit colors
get_col_match <- function(data){ 
  
 col_vec <- get_col_vec(data)
 
 col_out <- col_map %>% 
   filter(ind_3digit.naics_3digit_label %in% col_vec) %>% 
   select(emp_ind_vector) %>% 
   unlist() %>% 
   unname()
 
  return(col_out)
  
}
```

```{r}
#Get County GEOIDS and crosswalks
cbp_geoid <- read.csv(here("County Data/5_digit_naics_2019.csv")) %>% 
  mutate(area_fips = str_sub(GEO_ID, -5)) %>% 
  select(GEO_ID, NAME, area_fips) %>% distinct()

cbp_empzes <- read.csv(here("County Data/5_digit_naics_2019.csv")) %>% 
  select(EMPSZES_LABEL, EMPSZES) %>% 
  distinct()

cbp_io <- readRDS(here("Input Output Data/cbp_manf_IO_crosswalk.RDS")) 
```


```{r, include = FALSE}
#read county-level manufacturing data
cbp_2019 <- read.csv(here("County Data/6_digit_naics_CBP.csv")) %>% 
  left_join(cbp_geoid) %>% 
  left_join(county_data) %>% 
  left_join(area_codes %>% select(st, state_abbr)) %>% 
  mutate(across(.cols = c(EMP, ESTAB), ~ gsub(",", "", .)),
    emp_num = as.numeric(EMP), 
    ESTAB = as.numeric(ESTAB)) %>% 
  filter(str_detect(NAME, "Mariana", negate = TRUE)) %>% 
  left_join(cbp_empzes)
```


```{r}
cbp_2019_all <- read.csv(here("County Data/total_naics_2019.csv")) %>% 
  mutate(across(.cols = c(EMP, ESTAB), ~ gsub(",", "", .)),
    tot_emp = as.numeric(EMP), 
    tot_estab = as.numeric(ESTAB)) %>% 
  filter(str_detect(NAME, "Mariana", negate = TRUE), EMPSZES_LABEL == "All establishments") %>% 
  mutate(geo_merge = NAME) %>% 
  left_join(counties_leaflet %>% 
              mutate(geo_merge = paste(NAMELSAD, STATE_NAME, sep = ", ")) %>% 
              rename(county_name = NAME))
```



```{r}
#read Input Output Data
use_table_final <- readRDS(here("Input Output Data/use_table_final.RDS"))
sup_com_agg <- readRDS(here("Input Output Data/sup_com_agg.RDS"))
ind_agg <- readRDS(here("Input Output Data/ind_agg.RDS"))
com_agg <- readRDS(here("Input Output Data/com_agg.RDS"))
supply_table_final <- readRDS(here("Input Output Data/supply_table_final.RDS"))
```


```{r}
#Read NAICS Codes
naics_codes <- read.csv(here("NAICS/naics_codes.csv")) %>% 
  select(c(2,3))

colnames(naics_codes) <- c("industry_code", "industry_desc")
```

```{r, include = FALSE}
naics_2 <- naics_codes %>% 
  filter(str_length(industry_code) == 2 | industry_code == "31-33") %>% 
  mutate(industry_code = case_when(
    industry_code == "31-33" ~ 31.33, 
    TRUE ~ as.numeric(industry_code)
  ))
```

```{r}
naics_sub <- function(var, num){
   as.numeric(str_sub({{ var }}, 1, num))
}
```

# Overview

This document performs a geospatial mapping of manufacturing activity based on shared use and supply of various commodities. This analysis differentiates between horizontal (peer) agglomeration and vertical (supply-chain) agglomeration. We combine employment and establishments data from the US Census County Business Patterns (CBP) with commodity use and supply data from the Bureau of Economic Analysis’ Input-Output (IO) Accounts. The County Business Patterns is “an annual series that provides subnational economic data for establishments with paid employees by industry and employment size.” Input-Output accounts data provide a summary of how industries interact with each other and the economy. This measure currently uses CBP data from 2019, and IO data from 2017 and is thereby also the most current measure of agglomeration in manufacturing that exists. Both IO and CBP data have been extensively used to study how industries are related to one another. Delgado, Porter, and Stern (2014, 2016) use IO data from 2002 to capture which industries share common inputs or produce common outputs. Feser and Bergman (2000) use IO data from 1987 to understand how industries are related to one another based on a principal component analysis (PCA) of industry correlation in: use of similar inputs, production of similar outputs; and similar buying-selling patterns. Similarly, Delgado, Porter, and Stern (2014, 2016) use CBP data up to 2016 to measure which industries co-locate together (in terms of employment and establishments), and Hausmann et al. (2022) use CBP data up to 2011 to estimate the implied comparative advantage in a particular sector for a given region. Drawing from this previous use of IO and CBP data, we define new measures of agglomeration that focus on the manufacturing sector and its suppliers. 


# Connecting Use and Supply 

## Theoretical Background

The connection of use and supply tables is a complicated task. Extensive work has been done using Input-Output tables to identify national clusters of US industries (Delgado and Mills, 2020; Delgado et al., 2014; Feser and Bergman, 2010), deriving between 22 and 28 unique clusters (on the order of magnitude of 3-digit NAICS manufacturing codes). Input-output data have also been used to study the impact of trade shocks across the value chain (ADH 2013), and the impact of these shocks on local labor markets. Less work has been done to identify how the use and supply of commodities by industries might vary geographically, and how regions and industries might agglomerate in different ways depending on the composition of outputs they produce and the inputs that they demand. Because previous work has been focused on understanding how industries are connected in general, they chose not to focus on regional variation in the use and supply of commodities. I leverage the fact that industries are sparsely and heterogenously distributed across the United States to highlight new geographic and industrial patterns in the structure and composition of contemporary manufacturing activity. 

The 2017 Input-Output Accounts Data cover the domestic supply and use of commodities by 405 industries. These data provide the dollar value of the output and use of commodities. The lack of quantity information certainly complicates this analysis, as certain commodities are per-unit more valuable. However, these data still provide a baseline for estimating linkages between industries sectors. 

For a given industry $i$, let $X_i$ be the vector of commodities that industry i purchases as intermediate inputs (minus imports). Let $Y_i$ be the vector of commodities that industry $i$ outputs (minus exports). Adding imports and exports is saved as a robustness check. 

Let $\bf{Y_{i,c}}$ then be a matrix with columns representing industries and the rows representing the value of the commodities that these industries output. Focusing on the manufacturing sector, the input-output supply table data results in a 232x255 matrix of 232 manufacturing industries (i), and their output of 255 commodities (c). The first measure I define is $y_{i,c}$: the share of the total value of commodity $c$ ($C =\sum_{i}c_i$) produced by manufacturing industry $i$ ($P_{i,c}$): $\frac{P_{i,c}}{C}$ 

To measure the degree to which two industries produce similar outputs, I measure the correlation between the vector of outputs produced by industry $i$, and the vector of outputs produced by other industries $j$. We are interested in determining $R(Y_{i}, Y_{j})$, or the correlation between the output vector of industry i with industry j

Let $X_{C_i}$ be a matrix with columns representing industries and rows representing the value of the commodities that these industries purchase. Focusing on the manufacturing sector, the input-output use table results in a 232x326 matrix of 232 manufacturing industries (i), and their use of 326 commodities (c). The first measure I define is $x_{i,c}$: the value of commodity c as an intermediate input in industry i ($u_{i,c}$) over the total value of intermediate inputs used by industry $i$ ($u_{i}=\sum_cu_{i,c}$): $\frac{u_{i,c}}{u_i}$

With this matrix, there are two other matricies that we can determine. First, we can measure $R(X_i,X_j)$, which measures the correlation between input vectors of industries $i$ and $j$. However, we theorize that a measure of the common use of inputs will also reflect peer effects of agglomeration, rather than the supply chain effects that we are interested in contrasting peer effects against. 

Fortunately, we can also estimate $R(X_i,Y )$, or the correlation between the input vector of industry $i$ and the output vector of industry $j$. 

## Implementation

The above calculations can be constructed with the following datasets: the final use table, the final supply table, the industry aggregate table, and the commodity aggregate table. The construction of these datasets are provided in the input_output.rmd cleaning file. 

I make some initial cleaning adjustments to some of these tables to begin. 

```{r}
#Take the aggregate industry output measures and summarize them. 
manf_ind <- ind_agg %>% 
  mutate(naics_3digit = as.numeric(str_sub(industry_code, 1, 3))) %>% 
  left_join(ind_3digit) %>% 
  filter(naics_3digit >= 300 & naics_3digit < 400) %>% 
  #FIX MISSING VALUES WITH 0
  mutate(across(.cols = c(3:7), ~ case_when(
    is.na(.) ~ 0, 
    TRUE ~ .)), 
    log_ind = log(industry_output), 
    log_value = log(value_added), 
    log_inputs = log(intermediary_inputs), 
    val_ratio = value_added/industry_output, 
    input_ratio = intermediary_inputs/industry_output, 
    log_imports = log(imports), 
    import_ratio = imports/intermediary_inputs) 
```


### Inputs 

```{r}
#focus on manufacturing sector, join with manufacturing aggregate and create share
manf_inputs <- use_table_final %>% 
  filter(naics_3digit >= 300 & naics_3digit < 400) %>% 
  select(-c(value, value_clean)) %>% 
  left_join(manf_ind) %>% 
  mutate(input_share = value_num / intermediary_inputs) %>% 
  ungroup() %>% 
  arrange(industry_code)
```

```{r}
#Create a crosswalk of industry codes to refer to
ind_crosswalk <- manf_inputs %>% 
  ungroup() %>% 
  select(industry_code, industry_desc, naics_3digit, naics_3digit_label) %>% 
  distinct() %>% 
  mutate(index = seq(n()))
```

```{r, eval = FALSE}
saveRDS(ind_crosswalk, here("Input Output Data/ind_crosswalk.RDS"))
```


```{r}
#get list of commodities used as inputs
com_list_inputs <- manf_inputs %>% 
  select(commodity_code) %>% 
  distinct() %>% 
  unlist() %>% 
  unname()
```

```{r}
#get list of industries from the use table
ind_list_inputs <- manf_inputs %>% 
  select(industry_code) %>% 
  distinct() %>% 
  unlist() %>% 
  unname()
```

Here, the individual row entries of the matrix $X_{C_i}$ are given by the value of each $x_{i,c}$. I create a 232x326 matrix of 232 manufacturing industries (i), and their use of 326 commodities (c).  

```{r}
#create wide dataframe with each row being an industry and each column being a commodity 
input_cluster_raw <- manf_inputs %>% 
  select(commodity_code, commodity_desc, industry_desc, industry_code, value_num, input_share) %>% 
  pivot_wider(id_cols = c(industry_desc, industry_code), values_from = value_num, names_from = commodity_code, values_fill = 0) 

input_cluster_share <- manf_inputs %>% 
  select(commodity_code, commodity_desc, industry_desc, industry_code, value_num, input_share) %>% 
  pivot_wider(id_cols = c(industry_desc, industry_code), values_from = input_share, names_from = commodity_code, values_fill = 0)
```


```{r}
input_matrix <- input_cluster_share %>% 
  select(-c(industry_code, industry_desc)) %>% 
  as.matrix()

input_matrix_raw <- input_cluster_raw %>% 
  select(-c(industry_code, industry_desc)) %>% 
  as.matrix()
```

```{r}
#Get ordering of inputs in the input database
input_ordering <- data.frame(commodity_code = colnames(input_matrix_raw)) %>%
  mutate(tal = seq(n()))
```

Introducing the supply of commodities requires a different database. 

### Outputs

```{r}
manf_supply <- supply_table_final %>% 
  filter(naics_3digit >= 300 & naics_3digit < 400) %>% #Focus on the manufacturing sector
  left_join(sup_com_agg) %>% # Aggregate commodity details
  mutate(manf_percent = value_num / commodity_output_raw) %>% #percentage of a given output that is manufactured by a given manufacturing industry
  left_join(ind_agg) %>% 
  mutate(supply_percent = value_num / industry_output) %>%  #percentage of total industry supply that a given output makes up
  group_by(industry_code) %>% 
  mutate(prod_num = n(), #Number of total products an industry produces 
         main_prod = max(supply_percent, na.rm = TRUE),
         manf_sup = manf_percent*supply_percent) %>% #Across all commodities an industry produces, the maximum of the percentage of total industry supply a given output makes up
  arrange(industry_code) %>% 
  ungroup()
```

```{r}
#get list of industries from the use table
ind_list_outputs <- manf_supply %>% 
  select(industry_code) %>% 
  distinct() %>% 
  unlist() %>% 
  unname()
```

```{r}
#Input and Output Industry lists are identical, so we focus on one) 
ind_list <- ind_list_inputs
```

I now create a 232 x 252 matrix, with the rows being individual industries, and columns being the commodities that industry outputs. The column number is indexed by a list of all commodity codes. 

```{r}
output_clustering <- manf_supply %>% 
  ungroup() %>% 
  select(commodity_code, commodity_desc, industry_desc, industry_code, value_num, manf_percent, supply_percent, manf_sup) %>% 
  pivot_wider(id_cols = c(industry_desc, industry_code), values_from = manf_percent, names_from = commodity_code, values_fill = 0) 
```

```{r}
output_matrix_raw <- output_clustering %>% 
  ungroup() %>% 
  select(-c(industry_desc, industry_code)) %>% 
  as.matrix()
```

```{r}
#Get ordering of commodities in the output matrix
output_ordering <- data.frame(commodity_code = colnames(output_matrix_raw)) %>%
  mutate(tal = seq(n()))
```

```{r}
#list of goods made by the manufacturing industry
com_list_outputs <- output_ordering %>% 
  ungroup() %>% 
  select(commodity_code) %>% 
  distinct() %>% 
  unlist() %>% 
  unname()
```

### Lambda_C

Unfortunately, data in the 2017 supply table do not differentiate production for use an intermediate input from production as a final output. For example, the value of use of Scientific R&D as an input is just over \$12,000, but the value of output of scientific R&D as a commodity is over \$650,000. Not every product is used as an intermediary product. Let $\lambda_c = c_{int} / c_{tot}$ be the share of the value of the total output of commodity c that is used as an intermediate input. At this point, I construct $\lambda_c$. 

```{r}
lambda_c <- com_agg %>% 
  mutate(com_share = intermediate / total_use) %>% 
  select(com_share, commodity_code) 
```

```{r}
#Restrict to only the manufacturing sector
lambda_c_manf <- lambda_c %>% 
  left_join(output_ordering, .) %>% 
  arrange(tal) %>% 
  mutate(com_share = case_when(
    is.na(com_share) ~ 0, 
    TRUE ~ com_share
  ))
```


### Final Analysis

There are three different measures of interest to create. 

1) Input Correlation (how industries use similar inputs)
2) Output Correlation (how industries produce similar outputs)
3) Supply of Inputs (how industries produce outputs used as inputs by other industries)

In our first paper, we only use the last two of these measures. 

In this section, I create each of these measures. I use the case of the semiconductor industry to contextualize calculations. 

```{r}
mat_holder <- matrix(0, 232, 232)
```

#### Inputs


Consider the case of the semiconductor and related devices manufacturing industry, industry 334413. This industry uses 109 different inputs, the majority of which come from semiconductor and related industries, and the next highest of which come from nonferrous metal manufacturing. 

```{r}
#Get Subset of Commodities used by Industry i
industry_inputs <- manf_inputs %>% 
    filter(industry_code %in% c("334413"), value_num > 0) 
```

```{r}
#Get List of Commodities used by industry I
input_list <- industry_inputs$commodity_code
```

```{r}
#Get Index for Inputs used by industry i
inputs_used <- which(com_list_inputs %in% input_list)
```

Other manufacturing industries vary in their use of similar inputs. The total share of intermediary inputs accounted for by the subset of inputs used by industry i varies substantially, and can be calculated.  

```{r}
#Create Subset of Inputs Matrix of use of the set of commodities used by i
input_results <- input_matrix[, inputs_used] %>% as.matrix()
```

```{r}
#Sum Use of Subset of Products
input_sums <- input_results %>% rowSums()
```

```{r}
#Create Dataframe of related industries
related_ind <- data.frame(input_results) %>% 
  mutate(ind_i = ind_list,
    row_sums = input_sums) %>% 
  select(row_sums, ind_i, everything()) %>% 
  rename(industry_code = ind_i) %>% 
  left_join(ind_crosswalk) 
```

We see that while some industries get a similar share of their total inputs from the same set of commodities as our focus industry, many industries get 40% or below of the total value of their intermediate inputs from this set of commodities. 

```{r}
hist(related_ind$row_sums)
```


```{r}
related_industries_graph <- related_ind %>% 
  ggplot(aes(x = row_sums, y = naics_3digit_label, fill = factor(naics_3digit_label))) + 
  geom_density_ridges(aes(), alpha = 0.7) + 
  geom_point(aes(), shape = 21) +
  scale_fill_manual(values = emp_ind_vector) + 
  guides(fill = "none") + 
  labs(x = "Total Share of Industry Intermediate Input in Supplied Commodities", y = 
         "NAICS 3-digit Summary") + 
  theme_bw() + 
  axis_theme

related_industries_graph
```

I apply a cutoff of 40%, and filter for industries that can account for at least 40% of their total use of intermediate inputs from the set of inputs used by industry i, leaving a total of 161 manufacturing industries (from an initial set of 232). 

```{r}
#Get share of total of value of commodities used by industry i
input_sum_check = related_ind %>% 
  filter(industry_code == "334413") %>% 
  select(row_sums) %>% #The share of value that the focal industry gets
  unlist() %>% 
  unname()

rel_ind <- related_ind %>% 
  filter(row_sums > (.4*input_sum_check)) 
```

```{r}
#Get index of related industries
rel_ind_index <- which(ind_list %in% rel_ind$industry_code) 
```

```{r}
#Final Matrix
rel_ind_matrix <- input_matrix[rel_ind_index, ]
```

```{r}
rel_ind_raw <- input_matrix_raw[rel_ind_index, ]
```

```{r}
#Index Industry I 
ind_index <- rel_ind %>% 
  mutate(tal = seq(n())) %>%
  filter(industry_code == "334413") %>% 
  select(industry_code, tal)
```

The above matrix details the share of the value of total intermediate inputs used by each industry that comes from each commodity $c$, across the subset of industries that get at least 40% of their total value of intermediate inputs from the set of inputs used by industry i. I calculate the correlation between a specific industry $i$'s input vector, and other industries input vectors as well. Here, the goal is to identify the subset of other industries that are most similar to industry $i$ in their use of the set of commodities used by manufacturing sector $i$.

##### Measures of Correlation

There are multiple different ways to measure correlation. In this case, we are interested in measuring correlations across industries, and can either measure correlation across a subset of industries that are somehow related to the target industry (e.g through use of common inputs or production of common outputs), or across the entire universe of industries. Here, I compare the results for these different approaches as they pertain to the semiconductor manufacturing industry. 

```{r}
#define function to calculate correlation for a subset of industries 
make_cor_matrix <- function(rel_matrix, industry, method){
  
  cor_mes <- as.dist(cor(t(rel_matrix), method = c(method))) %>% as.matrix()
  
  ind_cor_df <- data.frame(industry_code = rel_ind$industry_code, industry_cor = cor_mes[ind_index$tal,]) %>%
  right_join(ind_crosswalk) %>% 
  mutate(industry_i = industry)
  
  return(ind_cor_df)
}
```

```{r}
#define function to calculate correlation over all industries 
make_cor_matrix_full <- function(rel_matrix, industry, method){
  
  cor_mes <- as.dist(cor(t(rel_matrix), method = c(method))) %>% as.matrix()
  
  ind_cor_df <- data.frame(industry_code = related_ind$industry_code, industry_cor = cor_mes[ind_index$tal,]) %>%
  right_join(ind_crosswalk) %>% 
  mutate(industry_i = industry)
  
  return(ind_cor_df)
}
```


```{r}
#get list of inputs used by a target industry
compare_inputs <- function(industry){ 
  
  manf_inputs %>% 
    filter(industry_code == industry) %>% 
    mutate(input_share = value_num / intermediary_inputs) %>% select(commodity_desc, value_num, input_share) 
  
  }
```


```{r}
semi_inputs <- compare_inputs("334413")
```

```{r}
#Pearson tests on share and value

test1 <- make_cor_matrix(rel_ind_matrix, "334413", "pearson") #this one wins
test2 <- make_cor_matrix(rel_ind_raw, "334413", "pearson")

test3 <- make_cor_matrix_full(input_matrix, "334413", "pearson")
test4 <- make_cor_matrix_full(input_matrix_raw, "334413", "pearson")
```


```{r}
#Pearson v. Spearman tests, note raw v share  does not matter for spearman because it is a rank based calculation

ps_test1 <- make_cor_matrix(rel_ind_matrix, "334413", "spearman") #this one is the winner so far!!! 
ps_test2 <- make_cor_matrix_full(input_matrix, "334413", "spearman")

```

Based on a manual examination of the different outputs, I calculate the spearman correaltion coefficient over a subset of related industries (defined in this case as getting at least 50% of the value of their use of intermediate inputs from the set of inputs used by the target industry). 

##### Final Input Results

```{r}
#Get Correlation
ind_cor <- as.dist(cor(t(rel_ind_matrix), method = c("spearman"))) %>% as.matrix()
```


```{r}
#Build Final Correlation Dataframe
ind_cor_df <- data.frame(industry_code = rel_ind$industry_code, industry_cor = ind_cor[ind_index$tal,]) %>%
  right_join(ind_crosswalk) %>% 
  mutate(industry_i = "334413") 
```

```{r}
#Replace Focal industry Code from 0 to 1
ind_cor_df$industry_cor[ind_cor_df$industry_code == ind_index$ind_i] = 1
```

```{r}
#Here, we fix missing values to denote a lack of correlation, and assume that all industries that are negatively correlated with a focal industry are also uncorrelated. 

ind_cor_inputs <- ind_cor_df %>% 
  mutate(industry_cor = case_when(
    is.na(industry_cor) ~ 0, 
    industry_cor < 0 ~ 0, 
    TRUE ~ industry_cor
  ))
```


This final dataframe tells as about the similarity in use of inputs across somewhat related industries, and leaves missing values for industries that do not share some common use of inputs. 

```{r}

ind_cor_clean_graph <- ind_cor_inputs %>% 
  ggplot(aes(x = industry_cor, y = naics_3digit_label, fill = naics_3digit_label)) + 
  geom_density_ridges(aes(), alpha = 0.7) + 
  geom_point(aes(), shape = 21) + 
  scale_fill_manual(values = emp_ind_vector) + 
  guides(fill = "none") + 
  labs(x = "Correlation in Input Vector with Industry I", y = 
         "NAICS 3-digit Summary") + 
  theme_bw() + 
  axis_theme

ind_cor_clean_graph
```

### Generalized Input Correlations 

This above procedure must then be repeated many times, over the entire set of industries.  

```{r}
get_input_results <- function(industry){ 

  
  #Get List of Inputs for a specific industry I 
  industry_inputs <- manf_inputs %>% 
    filter(industry_code %in% industry, value_num > 0) 
  
  #Get List of Commodities used by industry I
  input_list <- industry_inputs$commodity_code
  #Get Index for Inputs used by industry i
  inputs_used <- which(com_list_inputs %in% input_list)
  
  #Create Subset of Inputs Matrix of use of the set of commodities used by i
  input_results <- input_matrix[, inputs_used] %>% as.matrix()
  #Sum Use of Subset of Products
  input_sums <- input_results %>% rowSums()
  
  #Create Dataframe of related industries
  related_ind <- data.frame(input_results) %>% 
    mutate(ind_i = ind_list,
      row_sums = input_sums) %>% 
    select(row_sums, ind_i, everything())
  
  #Get list of related industries
  input_sum_check = related_ind %>% 
    filter(ind_i == industry) %>% 
    select(row_sums) %>% 
    unlist() %>% 
    unname()

  rel_ind <- related_ind %>% 
  filter(row_sums > (.4*input_sum_check)) 
  
  #NOTE: for a very few industries, not all of the intermediate inputs used are accounted for by the list of commodities (perhaps some of the intermediate inputs are scrap?). As such, the threshold we use is .40 of the maximum value of total commmodities used as inputs. 
  
  #Get index of related industries
  rel_ind_index <- which(ind_list %in% rel_ind$ind_i) 
  #Final Matrix
  rel_ind_matrix <- input_matrix[rel_ind_index, ]
  
  #Get Correlation
  ind_cor <- as.dist(cor(t(rel_ind_matrix), method = c("spearman"))) %>% as.matrix()
  #Index Industry I 
  ind_index <- rel_ind %>% 
    mutate(tal = seq(n())) %>%
    filter(ind_i == industry) %>% 
    select(ind_i, tal)
  #Build Final Correlation Dataframe
  ind_cor_df <- data.frame(industry_code = rel_ind$ind_i, industry_cor = ind_cor[ind_index$tal,]) %>%
    right_join(ind_crosswalk) %>% 
    mutate(industry_i = industry)
  
  #Replace Industry I Code from 0 to 1
  ind_cor_df$industry_cor[ind_cor_df$industry_code == ind_index$ind_i] = 1
  
  #Fix missing and less than 0 values
  input_corrs <- ind_cor_df %>% 
    mutate(industry_cor = case_when(
    is.na(industry_cor) ~ 0, 
    industry_cor < 0 ~ 0, 
    TRUE ~ industry_cor
  ))

  return(input_corrs)
  
  }
```

```{r}
ind_cor_holder <- ind_cor_df[0,]

for (i in ind_list){
  #print(i)
  ind_cor_holder <- bind_rows(ind_cor_holder, get_input_results(i))
  
}

```

```{r}
input_results_final <- ind_cor_holder
```

```{r, eval = FALSE}
saveRDS(input_results_final, here("Input Output Data/input_results.RDS"))
```

```{r}
input_results_final <- readRDS(here("Input Output Data/input_results.RDS"))
```

### Production of Outputs

I now turn to measuring the output correlation between industries. In a way, output correlations are reflected in NAICS groupings. In this section, I construct a measure of output correlations. 
Again, let us consider the case of the semi-conductor industry. 

```{r}
#Get Subset of Commodities produced by Industry i
industry_outputs <- manf_supply %>% 
    filter(industry_code %in% c("334413"), value_num > 0) 
```


```{r}
#Get List of Commodities produced by industry I
output_list <- industry_outputs$commodity_code
```

```{r}
#Get Index for outputs made by industry i
outputs_made <- which(com_list_outputs %in% output_list)
```

Other manufacturing industries vary in their production of similar outputs. 

```{r}
#Create Subset of Output Matrix of the production of commodities by i
output_results <- output_matrix_raw[, outputs_made] %>% as.matrix()
```

```{r}
#Sum of Production of products
output_sums <- output_results %>% rowSums()
```

```{r}
#Create Dataframe of related industries
output_related_ind <- data.frame(output_results) %>% 
  mutate(industry_code = ind_list,
    row_sums = output_sums) %>% 
  left_join(ind_crosswalk) %>% 
  select(row_sums, industry_code, industry_desc, naics_3digit_label, everything())
```

```{r}
output_related_industries_graph <- output_related_ind %>% 
  ggplot(aes(x = row_sums, y = naics_3digit_label, fill = factor(naics_3digit_label))) + 
  geom_density_ridges(aes(), alpha = 0.7) + 
  geom_point(aes(), shape = 21) + 
  scale_fill_manual(values = emp_ind_vector) + 
  guides(fill = "none") + 
  labs(x = "Total Share of Industry Intermediate Input in Supplied Commodities", y = 
         "NAICS 3-digit Summary") + 
  theme_bw() + 
  axis_theme

output_related_industries_graph
```

We see that many industries do not substantively produce the same set of outputs produced by the focal industry. To account for this, we eliminate industries that produce less than 20% of the total value of the set of commodities that are manufactured by the focal industry. 

```{r}
#Get list of related industries
output_sum_check = output_related_ind %>% 
  filter(industry_code == "334413") %>% 
  select(row_sums) %>% 
  unlist() %>% 
  unname()

output_rel_ind <- output_related_ind %>% 
  filter(row_sums > (.2*output_sum_check)) 
```

```{r}
#Get index of related industries
op_rel_ind_index <- which(ind_list %in% output_rel_ind$industry_code) 
```

```{r}
#Final Matrix
op_rel_ind_matrix <- output_matrix_raw[op_rel_ind_index, ] 
```

```{r}
#Index Industry I 
op_ind_index <- output_rel_ind %>% 
  mutate(tal = seq(n())) %>%
  filter(industry_code == "334413") %>% 
  select(industry_code, tal)
```

For consistency, I use the spearmans correlation over the set of industries that have at least 20% of their value in production of goods produced by industry i. 

```{r}
#Get Correlation
op_ind_cor <- as.dist(cor(t(op_rel_ind_matrix), method = c("spearman"))) %>% as.matrix()
```


```{r}
#Build Final Correlation Dataframe
op_ind_cor_df <- data.frame(industry_code = output_rel_ind$industry_code, industry_cor = op_ind_cor[op_ind_index$tal,]) %>%
  right_join(ind_crosswalk) %>% 
  mutate(industry_i = "334413")
```

```{r}
#Replace Industry I Code from 0 to 1
op_ind_cor_df$industry_cor[op_ind_cor_df$industry_code == op_ind_index$ind_i] = 1
```


```{r}
ind_cor_outputs <- op_ind_cor_df %>% 
  mutate(industry_cor = case_when(
    is.na(industry_cor) ~ 0, 
    industry_cor < 0 ~ 0, 
    TRUE ~ industry_cor
  ))
```

This final dataframe tells as about the similarity in use of inputs across somewhat related industries, and leaves missing values for industries that do not share some common use of inputs. 

```{r}
op_ind_cor_clean_graph <- ind_cor_outputs %>% 
  ggplot(aes(x = industry_cor, y = naics_3digit_label, fill = naics_3digit_label)) + 
  geom_density_ridges(aes(), alpha = 0.7) + 
  geom_point(aes(), shape = 21) + 
  scale_fill_manual(values = emp_ind_vector) + 
  guides(fill = "none") + 
  labs(x = "Correlation in Input Vector with Industry I", y = 
         "NAICS 3-digit Summary") + 
  theme_bw() + 
  axis_theme

op_ind_cor_clean_graph
```

### Generalized Output Correlations 

This above procedure must then be repeated many times, over the entire set of industries.  

```{r}
get_output_results <- function(industry){ 

  
  #Get List of Outputs for a specific industry I 
  industry_outputs <- manf_supply %>% 
    filter(industry_code %in% industry, value_num > 0) 
  
  #Get List of Commodities produced by industry I
  output_list <- industry_outputs$commodity_code
  #Get Index for outputs used by industry i
  outputs_made <- which(com_list_outputs %in% output_list)
  
  #Create Subset of Output Matrix of use of the set of commodities used by i
  output_results <- output_matrix_raw[, outputs_made] %>% as.matrix()
  #Sum Use of Subset of Products
  output_sums <- output_results %>% rowSums()
  
  #Create Dataframe of related industries
  op_related_ind <- data.frame(output_results) %>% 
    mutate(ind_i = ind_list,
      row_sums = output_sums) %>% 
    select(row_sums, ind_i, everything())
  
  #Get list of related industries
  op_sum_check = op_related_ind %>% 
    filter(ind_i == industry) %>% 
    select(row_sums) %>% 
    unlist() %>% 
    unname()

  op_rel_ind <- op_related_ind %>% 
  filter(row_sums > (.2*op_sum_check)) 
  
  #Get index of related industries
  op_rel_ind_index <- which(ind_list %in% op_rel_ind$ind_i) 
  #Final Matrix
  op_rel_ind_matrix <- output_matrix_raw[op_rel_ind_index, ]
  
  #Get Correlation
  op_ind_cor <- as.dist(cor(t(op_rel_ind_matrix), method = c("spearman"))) %>% as.matrix()
  #Index Industry I 
  op_ind_index <- op_rel_ind %>% 
    mutate(tal = seq(n())) %>%
    filter(ind_i == industry) %>% 
    select(ind_i, tal)
  #Build Final Correlation Dataframe
  op_ind_cor_df <- data.frame(industry_code = op_rel_ind$ind_i, industry_cor = op_ind_cor[op_ind_index$tal,]) %>%
    right_join(ind_crosswalk) %>% 
    mutate(industry_i = industry)
  
  #Replace Industry I Code from 0 to 1
  op_ind_cor_df$industry_cor[op_ind_cor_df$industry_code == op_ind_index$ind_i] = 1
  
  ind_cor_outputs <- op_ind_cor_df %>% 
    mutate(industry_cor = case_when(
    is.na(industry_cor) ~ 0, 
    industry_cor < 0 ~ 0, 
    TRUE ~ industry_cor
  ))

  return(ind_cor_outputs)
  
  }
```

```{r}
op_ind_cor_holder <- op_ind_cor_df[0,]

for (i in ind_list){
  #print(i)
  op_ind_cor_holder <- bind_rows(op_ind_cor_holder, get_output_results(i))
  
}

```

```{r}
output_results_final <- op_ind_cor_holder
```

```{r, eval = FALSE}
saveRDS(output_results_final, here("Input Output Data/output_results.RDS"))
```

```{r}
output_results_final <- readRDS(here("Input Output Data/output_results.RDS"))
```


### Supply of Inputs

I conclude by finally combining the supply and use tables together. As before, I test this procedure out for the semiconductor and related device manufacturing industry. 

```{r}
industry = "334413"
```

This industry uses a total of 109 commodities. Of these 109 commodities, 73 are produced by the manufacturing sector. 

```{r}
#Get vector of inputs used by a sepcific industry i 
input_vec <- manf_inputs %>% 
  filter(industry_code %in% c(industry), value_num > 0) %>% 
  select(commodity_code, commodity_desc, input_share, value_num, naics_3digit_label) %>% 
  distinct()

#Get List of Inputs for a specific industry I 
  input_list <- input_vec %>% 
    select(commodity_code) %>% 
    unlist() %>% 
    unname()

# Restrict to inputs produced by the manufacturing sector
input_vec_manf <- input_vec %>% 
  filter(commodity_code %in% com_list_outputs) %>% 
  left_join(output_ordering) %>% 
  arrange(tal)
```

```{r}
#Match the commodity codes to the index of commodity codes we have (supply)
  com_list_sup <- which(com_list_outputs %in% input_list) %>% 
    unlist() %>% 
    unname()

#Get the list of supplied commodities
  supplied_commodities <- com_list_outputs[com_list_sup]
  
  #Get the lambda_c vector for these commodities
  lambda_inputs <- lambda_c_manf %>% 
      filter(commodity_code %in% supplied_commodities) %>% 
      select(com_share) %>% 
      unlist() %>% 
      unname() 
```

Thus, we can create a matrix that accounts for how other manufacturing industries contribute to the supply of inputs used by industry i. 

```{r}
  #From the matrix of outputs $Y_{i,c}$, extract the columns that correspond to the inputs used by industry $i$. 
  output_matrix <- output_matrix_raw[, com_list_sup] %>% as.matrix()
```

This gives us a matrix of the production of inputs used by industry i, by all other industries j. 


Since not all products are used at the same intensity as intermediary products, we must adjust this matrix.  

```{r}
#Get the lambda_c vector
lambda_inputs <- lambda_c_manf %>% 
    filter(commodity_code %in% supplied_commodities) %>% 
    select(com_share) %>% 
    unlist() %>% 
    unname() 
```


```{r}
# Perform element wise multiplication across the rows to normalize by use of commodity as an input
 com_adj <- output_matrix*lambda_inputs
```

Industries vary in the degree to which they supply the mixture of manufactured inputs that are used by the focal industry. 

```{r}
#Sum of Production of products
supply_sums <- com_adj %>% rowSums()
```

```{r}
#Create Dataframe of related industries
supply_related_ind <- data.frame(com_adj) %>% 
  mutate(industry_code = ind_list,
    row_sums = supply_sums) %>% 
  left_join(ind_crosswalk) %>% 
  select(row_sums, industry_code, industry_desc, naics_3digit_label, everything())
```

```{r}
supply_related_industries_graph <- supply_related_ind %>% 
  ggplot(aes(x = row_sums*100, y = naics_3digit_label, fill = factor(naics_3digit_label))) + 
  geom_density_ridges(aes(), alpha = 0.7) + 
  geom_point(aes(), shape = 21) + 
  scale_fill_manual(values = emp_ind_vector) + 
  guides(fill = "none") + 
  labs(x = "Total Share of Industry Intermediate Input in Supplied Commodities", y = 
         "NAICS 3-digit Summary") + 
  theme_bw() + 
  axis_theme

supply_related_industries_graph
```

We manually correct for industries that are deemed to not "substantially supply" the target industries. These industries are defined as industries that on average, contribute less than 10% to the total supply of the vector of manufactured commodities used by the focal industry. 


```{r}
#Get share of total of value of commodities used by industry i
supply_sum_check = supply_related_ind %>% 
  filter(industry_code == "334413") %>% 
  select(row_sums) %>% #The share of value that the focal industry gets
  unlist() %>% 
  unname()

sup_rel_ind <- supply_related_ind %>% 
  filter(row_sums > (.1*supply_sum_check)) 
```

```{r}
#Get index of related industries
sup_rel_ind_index <- which(ind_list %in% sup_rel_ind$industry_code) 
```

```{r}
#Final Matrix
sup_rel_ind_matrix <- com_adj[sup_rel_ind_index, ]
```

```{r}
#Index Industry I 
sup_ind_index <- sup_rel_ind %>% 
  mutate(tal = seq(n())) %>%
  filter(industry_code == "334413") %>% 
  select(industry_code, tal)
```

Now, we can measure the correlation between the vector of inputs used by a given industry, and all other industries. 

```{r}
#isolate vector of inputs
ind_inputs <- input_vec_manf$input_share 

focus_commodities <- input_vec_manf$commodity_code
```

```{r}
#add vector of inputs to output matrix
supply_matrix <- sup_rel_ind_matrix %>% rbind(ind_inputs %>% t())
```

```{r}
#get correlation
supply_corr <- cor(t(supply_matrix), method = c("spearman"))
```

```{r}
#replace missing values with 0
supply_corr <- replace(supply_corr, is.na(supply_corr), 0)
```

```{r}
#convert to distance 
supply_corr <- as.dist(supply_corr) %>% as.matrix()
```

```{r}
sup_row <- nrow(supply_corr)
```


```{r}
ind_supply <- data.frame(industry_code = sup_rel_ind$industry_code, industry_cor = supply_corr[sup_row, -sup_row]) %>%
  right_join(ind_crosswalk) %>% 
  mutate(industry_i = "334413")
```


```{r}
ind_corr_supply <- ind_supply %>% 
  mutate(industry_cor = case_when(
    is.na(industry_cor) ~ 0, 
    industry_cor < 0 ~ 0, 
    TRUE ~ industry_cor
  ))
```

### Generalize Supply 

We now define a function to replicate this across industries. 

```{r}
#Get correlation between industry inputs and other industry outputs 
get_supply_results <- function(industry){
  
  #Get vector of inputs used by a sepcific industry i 
  input_vec <- manf_inputs %>% 
    filter(industry_code %in% c(industry), value_num > 0) %>% 
    select(commodity_code, commodity_desc, input_share, value_num, naics_3digit_label) %>% 
    distinct()

  #Get List of Inputs for a specific industry I 
  input_list <- input_vec %>% 
    select(commodity_code) %>% 
    unlist() %>% 
    unname()

  #Restrict to inputs produced by the manufacturing sector
  input_vec_manf <- input_vec %>% 
    filter(commodity_code %in% com_list_outputs) %>% 
    left_join(output_ordering) %>% 
    arrange(tal)

  #Match the commodity codes to the index of commodity codes we have (supply)
  com_list_sup <- which(com_list_outputs %in% input_list) %>% 
    unlist() %>% 
    unname()

  #Get the list of supplied commodities
  supplied_commodities <- com_list_outputs[com_list_sup]
  
  #From the matrix of outputs $Y_{P_i}$, extract the columns that correspond to the inputs used by industry $i$. 
  output_matrix <- output_matrix_raw[, com_list_sup] %>% as.matrix()
  
  #Get the lambda_c vector
  lambda_inputs <- lambda_c_manf %>% 
      filter(commodity_code %in% supplied_commodities) %>% 
      select(com_share) %>% 
      unlist() %>% 
      unname()
  
  # Perform element wise multiplication across the rows to normalize by use of commodity as an input
  com_adj <- output_matrix*lambda_inputs
  #Sum of Production of products
  supply_sums <- com_adj %>% rowSums()
  
  #Create Dataframe of related industries
  supply_related_ind <- data.frame(com_adj) %>% 
    mutate(industry_code = ind_list,
      row_sums = supply_sums) %>% 
    left_join(ind_crosswalk) %>% 
    select(row_sums, industry_code, industry_desc, naics_3digit_label, everything())
  
  #Get share of total of value of commodities used by industry i
  supply_sum_check = supply_related_ind %>% 
    filter(industry_code == industry) %>% 
    select(row_sums) %>% #The share of value that the focal industry gets
    unlist() %>% 
    unname()
  
  sup_rel_ind <- supply_related_ind %>% 
    filter(row_sums > (.1*supply_sum_check)) 
  #Get index of related industries
  sup_rel_ind_index <- which(ind_list %in% sup_rel_ind$industry_code) 
  #Final Matrix
  sup_rel_ind_matrix <- com_adj[sup_rel_ind_index, ]
  #Index Industry I 
  sup_ind_index <- sup_rel_ind %>% 
    mutate(tal = seq(n())) %>%
    filter(industry_code == industry) %>% 
    select(industry_code, tal)
  
  #isolate vector of inputs
  ind_inputs <- input_vec_manf$input_share 

  focus_commodities <- input_vec_manf$commodity_code

  #add vector of inputs to output matrix
  supply_matrix <- sup_rel_ind_matrix %>% rbind(ind_inputs %>% t())
  #get correlation
  supply_corr <- cor(t(supply_matrix), method = c("spearman"))
  
  #convert to distance 
  supply_corr <- as.dist(supply_corr) %>% as.matrix()
  
  #get number of rows in supply matrix
  sup_row <- nrow(supply_corr)

  #build final dataset
  ind_supply <- data.frame(industry_code = sup_rel_ind$industry_code, industry_cor = supply_corr[sup_row, -sup_row]) %>%
    right_join(ind_crosswalk) %>% 
    mutate(industry_i = industry)

  supply_results <- ind_supply %>% 
    mutate(industry_cor = case_when(
      is.na(industry_cor) ~ 0, 
      industry_cor < 0 ~ 0, 
      TRUE ~ industry_cor
    ))
  
  return(supply_results)
}
```



```{r}
sup_ind_cor_holder <- ind_supply[0,]

for (i in ind_list){
  #print(i)
  sup_ind_cor_holder <- bind_rows(sup_ind_cor_holder, get_supply_results(i))
  
}

```

```{r}
supply_results_final <- sup_ind_cor_holder
```

```{r, eval = FALSE}
saveRDS(supply_results_final, here("Input Output Data/supply_results.RDS"))
```

```{r}
supply_results_final <- readRDS(here("Input Output Data/supply_results.RDS"))
```


### Final Measures


At the conclusion of this analysis, the input-output tables yield 3 separate measures of how industries are related. I define these matricies now. 


1. $r(x_{i,c}, x_{j,c})$: measures the degree to which industries $i$ and $j$ use the same input mix. This measure captures vertical agglomeration. 

```{r}
input_matrix_final <- input_results_final %>% 
  select(industry_cor, industry_code, industry_i) %>% 
  pivot_wider(id_cols = industry_i, names_from = industry_code, values_from = industry_cor) %>% 
  select(-c(industry_i))
```


2. $r(y_{i,p}, y_{j,p})$: measures the degree to which industries $i$ and $j$ produce the same output mix, highly correlated with NAICS. This measure captures horizontal agglomeration

```{r}
output_matrix_final <- output_results_final %>% 
  select(industry_cor, industry_code, industry_i) %>% 
  pivot_wider(id_cols = industry_i, names_from = industry_code, values_from = industry_cor) %>% 
  select(-c(industry_i))
```


3. $r(x_{i,c}, y_{j,p})$ measures the degree to which industries $i$ and $j$ source inputs from similar sets of suppliers. This measures is an improved measure of vertical agglomeration from (1). 


```{r}
supply_matrix_final <- supply_results_final %>% 
  select(industry_cor, industry_code, industry_i) %>% 
  pivot_wider(id_cols = industry_i, names_from = industry_code, values_from = industry_cor) %>% 
  select(-c(industry_i))
```

As a note, while the input and output matrices are symmetric, the supply matrix is not. Valid entries are rows, that detail how other industries supply a given industry. Columns in this matrix can then be thought of as the degree to which a given industry supplies other manufacturing industries. 


# From Industries to Geographies

Using the above constructed Input Output Data, I now map the use and supply of commodities by the manufacturing sector to county-level establishments details. The geographic distribution of manufacturing activity is heterogeneous and sparse. Defining the use or supply of a given vector of commodities by industries located in a county requires some measure of the absolute and relative intensity of county-level industrial activity. Following in Delgado et. al, 2014, I use employment and establishments as the main measure of county-level industrial activity. This analysis could easily be extended to use GDP or sales as a measure. 

## Theoretical Background 

The sparse geographic location of 6-digit level manufacturing establishments allows for a careful investigation of the use and supply of commodities by the manufacturing sector. Let $m$ be the total number of manufacturing industries, and $n$ be the total number of counties across the nation. For each county $g$ and manufacturing industry $i$, let $s_{i,g}$ be the share of national industry activity in that county. This measure captures the total concentration of industry activity that occurs in a specific county. Let $E_{i,g}$ represent a given measure (employment or establishment) of industry activity in a county. 

$$s_{i,g} = \frac{E_{i,g}}{\sum_{i,g}E_{i,g}}$$

This is the main measure that we will use. 

Eventually, this measure needs to be modified to account for skews in concentration of certain industries in certain geographies. Fortunately, the location quotient for an industry provides for a standard and useful correction here. The location quotient is defined as the county's share of a specific industry, divided by the average county share for that industry across the nation:

$$LQ_{g,i} = \frac{s_{i,g}}{( \frac{1}{n} \sum_{g=1}^{n} s_{i,g})}$$


There are multiple levels to measure economic activity across. 1) The county, industry share of total industry activity; 2) the county, industry share of county activity; 3) the county industry share of regional (state, economic area) activity. We plan on exploring how slicing economic activity at these different levels impacts our measurement of agglomeration. 

The above Input-Output section maps industry activity to the production and use of specific vectors of commodities. As such, I do not need to specifically map individual industries to commodities. Instead, I estimate the relatedness between a specific manufacturing sub-sector $i_g$ and the manufacturing sub-sectors located within a specific distance from that sub-sector as a function of that county's industrial activity in a given sub-sector, $s_{g,i}$, and the derived input-output measure of the relatedness between geographically differentiated manufacturing sub-sectors $i_g$ and $j_g$, for all $j_g$ within a specific radius of the county of interest (let the set of these counties and industries be given by $\theta$). 

$$s_{i,g}*r(i_g, j_g \forall g \in \theta)$$

This specification allows for testing the robustness of this analysis to different geographic thresholds of distance (such as defined by commute patterns), as well as different thresholds for industrial measures of relatedness. However, it also allows for the plotting of raw values of industrial relatedness based on geographic distances. 

## Implementation

I turn to the implementation of the above measures across 2019 County Business Pattern Data, with 2017 Input Output Accounts Data. The goal of this section of analysis is to derive three specific measures for each county-subsector pairing that measure the three types of relatedness between industries derived from the input-output data. 

Input-Output Data accounts aggregate NAICS codes at a slightly different level than the CBP does. I use a crosswalk between the CBP NAICS codes and the Input-Output NAICS codes. The standard definition for industries will generally be the IO NAICS code definition. For the purposes of this analysis, I do not differentiate by the establishment sizes in each county and sub-sector, and instead look across all establishments. I create two measures: one that retains the granularity of the original NAICS weighting, and one that aggregates over industry codes available in the input-output data tables. 

```{r}
cbp_all <- cbp_2019_all %>% select(county_tot_emp = tot_emp, county_tot_estabs = tot_estab, NAME)
```


```{r}
cbp_state <- read.csv(here("County Data/state_total_2019.csv")) %>% 
  filter(LFO == 1, EMPSZES == 1) %>% 
  select(area_title = NAME, state_estabs = ESTAB, state_emp = EMP) %>% 
  left_join(area_codes %>% select(-c(area_fips))) %>% 
  filter(!is.na(st))
```


```{r}
cbp_merge <- cbp_2019 %>% 
  filter(EMPSZES == 1) %>% 
  left_join(cbp_all) %>% 
  left_join(cbp_state) %>% 
  left_join(cbp_io) %>% 
  ungroup() %>% 
  # group_by(NAICS2017_LABEL) %>% 
  # mutate(NAICS_tot_estab_nat = sum(ESTAB), 
  #        NAICS_tot_emp_nat = sum(emp_num), 
  #        NAICS_share_emp = emp_num/NAICS_tot_emp_nat, 
  #        NAICS_share_estab = ESTAB/NAICS_tot_estab_nat) %>% 
  # ungroup() %>% 
  # mutate(NAICS_estab_lq = NAICS_share_estab / mean(NAICS_share_estab), 
  #        NAICS_emp_lq = NAICS_share_emp / mean(NAICS_share_emp)) %>% 
  group_by(ind_code, NAME) %>% 
  mutate(county_ind_tot_estabs = sum(ESTAB),
         county_ind_tot_emp = sum(emp_num)) %>% 
  ungroup() %>% 
  group_by(ind_code) %>% 
  mutate(ind_tot_estab_nat = sum(ESTAB), 
         ind_tot_emp_nat = sum(emp_num), 
         ind_share_emp = county_ind_tot_emp/ind_tot_emp_nat, #THESE ARE THE MEASURES WE USE
         ind_share_estab = county_ind_tot_estabs/ind_tot_estab_nat ) %>% 
  ungroup() %>% 
  mutate(ind_estab_lq = ind_share_estab / mean(ind_share_estab), 
         ind_emp_lq = ind_share_emp / mean(ind_share_emp)) %>% 
  group_by(NAME) %>% 
  mutate(county_estabs = sum(ESTAB), 
           county_emp = sum(emp_num)) %>% 
  ungroup() 
  

```

```{r}
#Reduce to unique entries for each IO code
cbp_final_io <- cbp_merge %>% 
  filter(!is.na(ind_code)) %>% 
  group_by(NAME, ind_code) %>% 
  mutate(tal = seq(n())) %>% 
  filter(tal == 1) %>% 
  ungroup() %>%
  filter(!is.na(STATEFP)) %>% 
  arrange(NAME, ind_code) %>% 
  mutate(s_ri_estabs = county_ind_tot_estabs / county_tot_estabs, #share of county activity
       s_ri_emp = county_ind_tot_emp / county_tot_emp) %>% 
  group_by(NAME) %>% 
  mutate(x_r_estabs = mean(s_ri_estabs, na.rm = TRUE),
           x_r_emp = mean(s_ri_emp, na.rm = TRUE)) %>% 
  ungroup() %>% 
  mutate(county_share_emp = county_emp / sum(county_emp), 
         county_lq_emp = county_share_emp / mean(county_share_emp), 
         county_share_estabs = county_estabs / sum(county_estabs), 
         county_lq_estabs = county_share_estabs / mean(county_share_estabs)) %>%
  select(NAME, ind_code, industry_desc, s_ri_emp, ind_share_emp, ind_emp_lq, x_r_emp, county_share_emp, county_lq_emp, everything())

#NOTE: Not all counties in the US have manufacturing employment. As such, the dataframe cbp_2019_all has more counties than the above dataframe. Manufacturing activity accounts for a small share of establishments. As such, we continue to focus on the manufacturing sector, and do not bring in county level totals for employment and establishments. 
```


Our final dataframe contains county-level estimates for $\phi_{i,g}$ as well as $LQ_{g,i}$.I use these variables to calculate $\tilde{A}_{g,i}$. 

## Analysis

I now create a procedure to 1) identify the other industries within a specific county; 2) identify the counties that are located within a specific radius $\theta$ of the county, 3) identifiy the industries that are within these counties, 4) subset the industry relatedness measures with these industries, 5) output a county-sub-sector level score. 

```{r}
#Get dataframe of county geographies to merge against
county_coords <- counties_leaflet %>% 
  select(GEO_ID = AFFGEOID, state_fips = STATEFP, county_fips = COUNTYFP, geometry)
```

```{r}
#Get dataframe of county geography centers to merge against
county_coords_center <- county_centers %>% 
  select(GEO_ID = AFFGEOID, state_fips = STATEFP, county_fips = COUNTYFP, geometry)
```

```{r}
#Merge this with the CBP dataframe
cbp_geog <- cbp_final_io %>% 
  filter(!is.na(state_abbr)) %>% 
  select(-c(STATEFP, COUNTYFP)) %>% 
inner_join(county_coords) 
```

```{r}
#Get ordered list of counties in the dataframe
county_list <- cbp_geog %>% 
  select(NAME) %>% 
  distinct() %>% 
  unlist() %>% 
  unname()
```

```{r}
# Convert data into 'sf' object
df_sf <- cbp_geog %>% 
    st_as_sf(crs = 4326) 
```

```{r, eval = FALSE}
county_map <- counties_leaflet %>% 
  leaflet %>% 
  setView(-97.59211, 37.91239, zoom = 4) %>% 
  addPolygons(
  fillColor = "grey",
  weight = 1,
  opacity = 0.5,
  color = "black",
  dashArray = "3",
  fillOpacity = 0.7, 
  highlightOptions = highlightOptions(
    weight = 5,
    color = "#666",
    dashArray = "",
    fillOpacity = 0.7,
    bringToFront = TRUE), label = counties_leaflet$NAMELSAD)
```

## Case Study: 

To build this procedure, I perform a case study analysis of multiple regional areas. The procedure I define will need to both loop through all counties in the data, as well as each sub-sector that is present in the final data. 

```{r}
la <- which(county_list %in% "Los Angeles County, California")
sno <- which(county_list %in% "Snohomish County, Washington")
lam <- which(county_list %in% "Lamar County, Alabama")
```

I start by getting the coordinates for the county. 

```{r}
  county_name <- c(county_list[sno])
  
  county_ind <- cbp_geog %>% 
    filter(NAME %in% county_name) %>% 
    arrange(ind_code)
  
  #get list of industries in county
  
  ind_in_county <- county_ind %>% 
    filter(!is.na(ind_code)) %>% 
    select(ind_code) %>% 
    distinct() %>%
    unlist() %>% 
    unname()
  
  focus_county_coords <- county_ind %>% 
    ungroup() %>% 
    select(GEO_ID, state_fips, county_fips, NAME, geometry) %>% 
    distinct()
```

```{r}
focus_center <- county_centers %>% 
  filter(AFFGEOID %in% focus_county_coords$GEO_ID)
```

Using the geometry object from this point, as well as the county data above, I compute the distance in miles between a given county, and all of the other counties in the dataset. I then merge these data back with specific variables of interest from the CBP data. 

```{r}
state_list <- states_leaflet %>% 
  as.data.frame() %>% 
  select(state_fips = STATEFP) %>% 
  distinct() %>% unlist() %>% unname()
```


```{r}
state_dist <- st_distance(states_leaflet$geometry, states_leaflet$geometry) %>% 
  set_units("mi") %>% 
    as.data.frame() %>% 
    drop_units() 
```

```{r}
results_state <- which(state_list %in% focus_county_coords$state_fips)
```

```{r}
near_states <- state_list[which(state_dist[results_state,] < 100)]
```

```{r}
sf_match <- df_sf %>% 
  filter(state_fips %in% near_states)
```

```{r}
# Compute the distance between the reference point and points from 'df_sf'
  results <- st_distance(focus_center$geometry, sf_match$geometry) %>% #focus_county_ccoords for by polygon, focus_center for center to polygon
    set_units("mi") %>% 
    t() %>% 
    as.data.frame() %>% 
    drop_units() %>% 
    `colnames<-`(., "dist_mi") 
  
  results$NAME <- sf_match$NAME
  results$NAICS2017 <- sf_match$NAICS2017
  results$NAICS2017_label <- sf_match$NAICS2017_LABEL
  results$industry_code <- sf_match$ind_code
  results$ind_share_emp <- sf_match$ind_share_emp
  results$ind_share_estabs <- sf_match$ind_share_estab
  
```

```{r}
results <- results %>%
  arrange(industry_code)
```

I now establish the set of industries that exist in this county, as well as the set of industries that exist within a specific geographic distance from the main county. 

```{r}
 #Get list of counties and industries within a geographic distance of county and industry i
  geog_ind <- results %>% 
    filter(dist_mi < 100) %>% 
    select(industry_code) %>% 
    distinct() %>% 
    unlist() %>% 
    unname()
```

For each of these industries, iterate over the list of all industries present within the specified geographic distance. To do this, rather than iterate over rows, I leverage the advantages of matrices and matrix multiplication. Using the above data, I create two JxG matrices, one defined by establishments, and one defined by employment, where the rows represent industries, and columns represents industrial activity in a specific county g.

### Set Geographic Radius

```{r}
geog_radius = 100
```

```{r}
county_ind_matrix <-  function(var){
  results %>% 
    filter(dist_mi <= geog_radius, !is.na(industry_code)) %>% 
    select(industry_code, NAME, {{ var }}) %>% 
    # mutate(log_val = log({{ var }})) %>% 
    distinct() %>% 
    pivot_wider(id_cols = industry_code, names_from = NAME, values_from = {{ var }}, values_fill = 0) %>% 
    select(-c(industry_code)) %>% 
    as.matrix()
} 
```


```{r}
county_radius <- results %>% 
    filter(dist_mi < 100, !is.na(industry_code)) 
```


```{r}
results_ind_emp <- county_ind_matrix(ind_share_emp)
results_ind_estabs <- county_ind_matrix(ind_share_estabs)
```

The resulting matrix tells us about the industries that are located within a 100 mile radius of county $g$.

Using the initial list of industries from earlier, I obtain a set of industry relatedness measures from the input output data, focusing on how industries are related to the industry of interest, $i$. I perform this task for each of the input, output, and supply correlation matrices. We correct this measure by the HHI for the county to account for how concentrated/diversified the county's industrial composition is. As HHI increases, the measure of 

```{r}
#create a helper function to get # of industries with 0 correlation 
zero_count <- function(matrix){ 
  
  #County the number of rows that that have 0 correlation value in them
  matrix_zeros <- matrix %>% 
    proxyC:: rowZeros()
  
  return(matrix_zeros)
  }
```

```{r}
final_matrix_calc <- function(matrix1, matrix2, hhi){
  
  result1 <- matrix1 %*% matrix2


  output <- rowMeans(result1)
  
  return(output)
}
```

### Inputs

```{r}
X_ij <- input_matrix_final %>% 
  as.matrix()
```


```{r}
#Use list of industries to get index of industries in relatedness measures
ind_list_index <- which(ind_list %in% geog_ind)

#Get list of industries in focus county
ind_i <- which(geog_ind %in% ind_in_county)
```

We obtain a subset of our input correlation matrix that tells us how the industries within a geographic radius of a focal county are related to one another. 

```{r}
input_agg <- X_ij[ind_list_index, ind_list_index] %>% as.matrix()
```

```{r}
input_zeros <- zero_count(input_agg)
```

For each relatedness matrix, I multiply by the geographic matrix defined in the above section.

```{r}
input_agg_emp <- final_matrix_calc(input_agg, results_ind_emp)
input_agg_estabs <- final_matrix_calc(input_agg, results_ind_estabs)
```

The resulting vector $\beta_{j,g}$ then has rows defined by the industries related to the target industry $i$, across the counties that are within a specific geographic distance of that county. An individual entry in this matrix is the sum of the geographically weighted correlation between the individual industry $i$ and all other industries in a given county g that falls within some radius of the initial county of interest. 

### Outputs

```{r}
Y_ij <- output_matrix_final %>% 
  as.matrix()
```

We obtain a subset of our output correlation matrix that tells us how the industries within a geographic radius of a focal county are related to one another. 

```{r}
#We are interested primarily in the rows of this matrix
output_agg <- Y_ij[ind_list_index, ind_list_index] %>% as.matrix()
```

```{r}
output_zeros <- zero_count(output_agg)
```

For each relatedness matrix, I multiply by the geographic matrix defined in the above section.

```{r}
output_agg_emp <- final_matrix_calc(output_agg, results_ind_emp)
output_agg_estabs <- final_matrix_calc(output_agg, results_ind_estabs)
```

### Supply 

We obtain a subset of our supply matrix that tells us how the industries within a geographic radius of a focal county are related to one another. 

```{r}
S_ij <- supply_matrix_final %>% 
  as.matrix()
```

```{r}
S_ij_upstream <- supply_matrix_final %>% 
  as.matrix %>% t()
```

```{r}
S_ij_all <- S_ij + S_ij_upstream
```

```{r}
diag(S_ij_all) = diag(S_ij_all)/2
```


```{r}
supply_agg <- S_ij_all[ind_list_index, ind_list_index] %>% as.matrix()
```

```{r}
supply_zeros <- zero_count(supply_agg)
```


For each relatedness matrix, I multiply by the geographic matrix defined in the above section.

```{r}
supply_agg_emp <- final_matrix_calc(supply_agg, results_ind_emp)
supply_agg_estabs <- final_matrix_calc(supply_agg, results_ind_estabs)
```

These values are collected, and then joined back with the initial county-subsector level data. Leveraging the fact that the initial indicies match, this becomes a rather simple task. 

```{r}
    county_ind$input_emp <- input_agg_emp[ind_i]
    county_ind$input_estabs <- input_agg_estabs[ind_i]
      
    county_ind$output_emp <- output_agg_emp[ind_i]
    county_ind$output_estabs <- output_agg_estabs[ind_i]
    
    county_ind$supply_emp <- supply_agg_emp[ind_i]
    county_ind$supply_estabs <- supply_agg_estabs[ind_i]
    
    county_ind$input_zeros <- input_zeros[ind_i]
    county_ind$output_zeros <- output_zeros[ind_i]
    county_ind$supply_zeros <- supply_zeros[ind_i]
    county_ind$total_inds <- length(ind_list_index)

```

This provides the final measure for each county-sub-sector entity (i,g), of the average correlation between that entity, and the other sub-sectors within a given geographic distance of the entity of interest. 

This procedure must then be repeated for every county in the dataset. 

## Expanding the Procedure. 

I start by defining an empty dataframe. 

```{r}
final_cbp_results <- county_ind[0,]
```

```{r}
for (i in 1:length(county_list)){
  
  county_name <- c(county_list[i])
  
  county_ind <- cbp_geog %>% 
    filter(NAME %in% county_name) %>% 
    arrange(ind_code)
  
  #get list of industries in county
  
  ind_in_county <- county_ind %>% 
    filter(!is.na(ind_code)) %>% 
    select(ind_code) %>% 
    distinct() %>%
    unlist() %>% 
    unname()

  #Get Coordinates of County
  focus_county_coords <- county_ind %>% 
    ungroup() %>% 
    select(GEO_ID, state_fips, county_fips, NAME, geometry) %>% 
    distinct()
  #Get Centers
  focus_center <- county_centers %>% 
    filter(AFFGEOID %in% focus_county_coords$GEO_ID)
  
  #Get State County is in 
  results_state <- which(state_list %in% focus_county_coords$state_fips)
  #Find nearby states
  near_states <- state_list[which(state_dist[results_state,] < 100)]
  #limit search pool
  sf_match <- df_sf %>% 
    filter(state_fips %in% near_states)
  
  # Compute the distance between the reference point and points from narrow pool
  results <- st_distance(focus_center$geometry, sf_match$geometry) %>% 
    set_units("mi") %>% 
    t() %>% 
    as.data.frame() %>% 
    drop_units() %>% 
    `colnames<-`(., "dist_mi") 
  
  results$NAME <- sf_match$NAME
  results$NAICS2017 <- sf_match$NAICS2017
  results$NAICS2017_label <- sf_match$NAICS2017_LABEL
  results$industry_code <- sf_match$ind_code
  results$ind_share_emp <- sf_match$ind_share_emp
  results$ind_share_estabs <- sf_match$ind_share_estab
  
  results <- results %>%
    arrange(industry_code)
  
  #Get list of industries within a geographic distance
  geog_ind <- results %>% 
    filter(dist_mi < geog_radius) %>% 
    select(industry_code) %>% 
    distinct() %>% 
    unlist() %>% 
    unname()
  
  #Create a J x G matrix of related industries and counties
  results_ind_emp <- county_ind_matrix(ind_share_emp)

  results_ind_estabs <- county_ind_matrix(ind_share_estabs)
  
  
  #Use list of industries to get index of industries in relatedness measures
  ind_list_index <- which(ind_list %in% geog_ind)
  
  ind_i <- which(geog_ind %in% ind_in_county)
  #There are 3 matrices of interest: X_Ci, Y_Pi, and M_ij. Subsetting these matricies by the index of industries i of interest, against the industries j that are present across geographies, produces a subset of this matrix that describes how each industry i is related to each other industry j in the data. 
  
  input_agg <- X_ij[ind_list_index, ind_list_index] %>% as.matrix()
  
  output_agg <- Y_ij[ind_list_index, ind_list_index]  %>% as.matrix()
  
  # peer_agg <- input_agg + output_agg
  
  supply_agg<- S_ij_all[ind_list_index, ind_list_index]  %>% as.matrix()
  
  # Get Zeros
  
  input_zeros <- zero_count(input_agg)
  output_zeros <- zero_count(output_agg)
  supply_zeros <- zero_count(supply_agg)


  #For each measure, apply a geographic weighting. 
  
  input_emp <- final_matrix_calc(input_agg, results_ind_emp)
  input_estab <- final_matrix_calc(input_agg, results_ind_estabs)
  
  output_emp <- final_matrix_calc(output_agg, results_ind_emp)
  output_estab <- final_matrix_calc(output_agg, results_ind_estabs)
  
  supply_emp <- final_matrix_calc(supply_agg, results_ind_emp)
  supply_estab <- final_matrix_calc(supply_agg, results_ind_estabs)
  
  # peer_emp <- final_matrix_calc(peer_agg, results_ind_emp)
    
    # county_ind$peer_emp <- peer_emp[ind_i]
    county_ind$input_emp <- input_emp[ind_i]
    county_ind$input_estabs <- input_estab[ind_i]
      
    county_ind$output_emp <- output_emp[ind_i]
    county_ind$output_estabs <- output_estab[ind_i]
    
    county_ind$supply_emp <- supply_emp[ind_i]
    county_ind$supply_estabs <- supply_estab[ind_i]
    
    county_ind$input_zeros <- input_zeros[ind_i]
    county_ind$output_zeros <- output_zeros[ind_i]
    county_ind$supply_zeros <- supply_zeros[ind_i]
    county_ind$total_inds <- length(ind_list_index)
    
  
  
  final_cbp_results <- bind_rows(final_cbp_results, county_ind)

}
```


```{r}
final_results <- final_cbp_results %>% 
  select(NAME, GEO_ID, state_abbr, ind_code, industry_desc, 
         output_emp, output_estabs, supply_emp, supply_estabs, input_emp, input_estabs, 
         total_inds, output_zeros, supply_zeros, input_zeros,
         ind_share_emp, ind_share_estab, ind_emp_lq, ind_estab_lq, 
         s_ri_emp, s_ri_estabs, x_r_emp, x_r_estabs, 
         county_share_emp, county_share_estabs, 
         county_lq_emp, county_lq_estabs, everything()
         )
```

```{r, eval = FALSE}
#Version with polygons
final_results %>% 
  saveRDS(here("Final Data/final_cbp_io_results_0526.RDS"))
```

```{r, eval = FALSE}
#Version with polygons
final_results %>% 
  saveRDS(here("Final Data/final_cbp_io_centers_0605_ud.RDS"))
```

```{r, eval = FALSE}
#Version with polygons
final_results %>% 
  saveRDS(here("Final Data/final_cbp_io_centers_0526.RDS"))
```

-----


```{r, eval = FALSE}
final_cbp_results %>% 
  saveRDS(here("Final Data/final_cbp_io_results.RDS"))
```

```{r, eval = FALSE}
#THIS VERSION IS THE ADJUSTED VERSION WITH ESTABLISHMENT WEIGHTING
final_cbp_results %>% 
  saveRDS(here("Final Data/final_cbp_io_results_hhi.RDS"))
```

```{r, eval = FALSE}
#THIS VERSION IS THE ADJUSTED VERSION WITH AREA ESTABLISHMENT WEIGHTING
final_cbp_results %>% 
  saveRDS(here("Final Data/final_cbp_io_results_area_hhi.RDS"))
```

```{r, eval = FALSE}
#THIS VERSION IS THE ADJUSTED VERSION WITH AREA ESTABLISHMENT WEIGHTING
final_cbp_results %>% 
  saveRDS(here("Final Data/final_cbp_io_results_nohhi.RDS"))
```

```{r, eval = FALSE}
#THIS VERSION IS THE ADJUSTED VERSION WITH AREA ESTABLISHMENT WEIGHTING
final_cbp_results %>% 
  saveRDS(here("Final Data/final_cbp_io_results_nohhi_250.RDS"))
```

```{r, eval = FALSE}
#THIS VERSION IS THE ADJUSTED VERSION WITH CORRELATION SUPPLY WEIGHTING
final_cbp_results %>% 
  saveRDS(here("Final Data/final_cbp_io_results_nohhi_supply_cor.RDS"))
```

```{r, eval = FALSE}
#THIS VERSION IS THE ADJUSTED VERSION WITH CORRELATION SUPPLY WEIGHTING
final_cbp_results %>% 
  saveRDS(here("Final Data/final_cbp_io_results_0522_noratio.RDS"))
```

```{r, eval = FALSE}
#THIS VERSION IS THE ADJUSTED VERSION WITH CORRELATION SUPPLY WEIGHTING
final_cbp_results %>% 
  saveRDS(here("Final Data/final_cbp_io_results_0522.RDS"))
```

```{r, eval = FALSE}
#THIS VERSION IS THE ADJUSTED VERSION WITH CORRELATION SUPPLY WEIGHTING
final_cbp_results %>% 
  saveRDS(here("Final Data/final_cbp_io_results_0522_og.RDS"))
```